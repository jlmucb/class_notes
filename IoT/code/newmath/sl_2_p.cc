#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <math.h>

// SL_2(p)
//  mat is
//    a  b
//    c  d
// Stored as abcd in array

void print_mat(int* m) {
  printf("| %02d %02d|\n", m[0], m[1]);
  printf("| %02d %02d|\n", m[2], m[3]);
}

void get_mat(int* m, int* a, int* b, int* c, int* d) {
  *a = m[0];
  *b = m[1];
  *c = m[2];
  *d = m[3];
}

void set_mat(int a, int b, int c, int d, int* m) {
  m[0] = a;
  m[1] = b;
  m[2] = c;
  m[3] = d;
}

int normalize(int p, int n) {
  if (n < 0) {
    int m = -n;
    m += p - 1;
    m /= p;
    n += p * m;
  }
  if (n >= p) {
    int m = n / p;
    n -= m * p;
  }
  return n;
}

int det(int p, int* m) {
  int a, b, c, d;

  get_mat(m, &a, &b, &c, &d);
  return normalize(p, a * d - b * c);;
}

bool mult_mat(int p, int* m1, int* m2, int* res) {
  int a1, b1, c1, d1;
  int a2, b2, c2, d2;
  int a, b, c, d;

  get_mat(m1, &a1, &b1, &c1, &d1);
  get_mat(m2, &a2, &b2, &c2, &d2);

  a = normalize(p, a1 * a2 + b1 * c2);
  b = normalize(p, a1 * b2 + b1 * d2);
  c = normalize(p, c1 * a2 + d1 * c2);
  d = normalize(p, c1 * b2 + d1 * d2);

  set_mat(a, b, c, d, res);
  return true;
}

void copy_mat(int* m1, int* m2) {
  for (int i= 0; i < 4; i++)
    m2[i]= m1[i];
}

bool is_equal(int* m1, int* m2) {
  int a1, b1, c1, d1;
  int a2, b2, c2, d2;

  get_mat(m1, &a1, &b1, &c1, &d1);
  get_mat(m2, &a2, &b2, &c2, &d2);

  return a1 == a2 && b1 == b2 && c1 == c2 && d1 == d2;
}

bool is_identity(int* m) {
  int a, b, c, d;
  get_mat(m, &a, &b, &c, &d);
  return a == 1 && b == 0 && c == 0 && d == 1;
}

int order(int p, int* m) {
  int t[4] = {
    1, 0, 0, 1
  };
  int r[4] = {
    0, 0, 0, 0
  };

  if (is_identity(m)) {
    return 1;
  }

  int ord = 0;
  for (;;) {
    mult_mat(p, m, t, r);
    ord++;
    copy_mat(r, t);
    if (is_identity(r)) {
      return ord;
    }
  }
  return -1;
}

class T {
public:
  int mat_[4];
  int order_;
};


class tabulate_orders {
public:
  int max_;
  int num_;
  int* orders_;
  int* tally_;

  tabulate_orders(int max);
  ~tabulate_orders();
  bool add_ord(int ord);
  void tab_order(int ord);
  bool pre_sort();
  void tab_print();
};

tabulate_orders::tabulate_orders(int max) {
  max_ = max;
  orders_ = new int[max];
  tally_ = new int[max];
}

tabulate_orders::~tabulate_orders() {
  if (orders_ != nullptr) {
    delete []orders_;
    orders_ = nullptr;
  }
  if (tally_ != nullptr) {
    delete []tally_;
    tally_ = nullptr;
  }
}

bool tabulate_orders::add_ord(int ord) {
  for (int i = 0; i < num_; i++) {
    if (orders_[i] == ord)
      return true;
  }
  if (num_ < (max_- 1)) {
    orders_[num_] = ord;
    tally_[num_++] = 0;
    return true;
  }
  return false;
}

void tabulate_orders::tab_print() {
  for (int i = 0; i < num_; i++)
    printf("number of elements of order %d is %d\n", orders_[i], tally_[i]);
}

void tabulate_orders::tab_order(int ord) {
  for (int i = 0; i < num_; i++) {
    if (orders_[i] == ord)
      tally_[i]++;
  }
}

bool tabulate_orders::pre_sort() {
  for (int i = 0; i < num_; i++) {
    int k = i;
    for (int j = i; j < num_; j++) {
      if (orders_[j] < orders_[k]) {
        k = j;
      }
    }

    if (k != i) {
      int t = orders_[i];
      orders_[i] = orders_[k];
      orders_[k] = t;
    }
  }
  return true;
}

// is c a power of b?
bool is_power(int p, int* b, int* c) {
  int r1[4], r2[4];

  if (is_equal(b,c))
    return true;
  copy_mat(b, r1);

  for (int i = 2; i < 8; i++) {
    if (!mult_mat(p, b, r1, r2))
      return false;
    if (is_equal(r2,c))
      return true;
    copy_mat(r2, r1);
  }
  return false;
}

void normalizer_test(int p, T* x, int n) {
  int r1[4], r2[4], r3[4], r4[4];
  int t1[4], t2[4], t3[4], t4[4];

  int i = 0;
  for (i = 0; i < n; i++) {
    if (x[i].order_ == 8)
      break;
  }

  // calculate a^(-1)
  int* a_mat = x[i].mat_;
  int a_inv[4];
  if (!mult_mat(p, a_mat, a_mat, r1))
    return;
  if (!mult_mat(p, r1, r1, r2))
    return;
  if (!mult_mat(p, r1, r2, r3))
    return;
  if (!mult_mat(p, a_mat, r3, a_inv))
    return;
  if (!mult_mat(p, a_mat, a_inv, r4))
    return;
  if (!is_identity(r4)) {
    printf("Can't compute identity\n");
    return;
  }

  printf("a: \n");
  print_mat(a_mat);
  printf("a^(-1): \n");
  print_mat(a_inv);
  printf("\n");

  for (int j = (i + 1); j < n; j++) {
    if (x[j].order_ != 8)
      continue;

    if (!mult_mat(p, a_inv, x[j].mat_, t1))
      return;
    if (!mult_mat(p, t1, a_mat, t2))
      return;

    if (is_power(p, x[j].mat_, t2)) {
      printf("normalizes group generated by: \n");
      print_mat(x[j].mat_);
      printf("conj is\n");
      print_mat(t2);
      printf("_________\n");
    }
#if 0
    printf("b: \n");
    print_mat(x[j].mat_);
    printf("a^(-1) b a: \n");
    print_mat(t2);
    printf("\n");
#endif
  }

}


int main(int an, char** av) {
  int p = 7;
  int to_print = 0;
  bool print_all = true;
  bool normalizer = false;

  if (an < 2) {
    printf("sl2p.exe --p=7 --print_ord=8 --print_all\n");
    return 0;
  }

  for (int i = 0; i < an; i++) {
    int n = strlen("--p=");
    if (strncmp(av[i], "--p=", n) == 0) {
      sscanf(&(av[i][n]), "%d", &p);
    }
    n = strlen("--print_ord=");
    if (strncmp(av[i], "--print_ord=", n) == 0) {
      sscanf(&(av[i][n]), "%d", &to_print);
    }
    if (strncmp(av[i], "--print_all", n) == 0) {
      print_all = true;
    }
    if (strncmp(av[i], "--normalize", n) == 0) {
      normalizer = true;
    }
  }

  T x[p*p*p*p];
  int n_t = 0;

  for (int i = 0; i < p; i++) {
    for (int j = 0; j < p; j++) {
      for (int k = 0; k < p; k++) {
        for (int l = 0; l < p; l++) {
          int m[4];

          set_mat(i, j, k, l, m);
          if (det(p, m) == 1) {
            int ord = order(p, m);
            copy_mat(m, x[n_t].mat_);
            x[n_t++].order_ = ord;
          }
        }
      }
    }
  }

  printf("p= %d, %d elements\n", p, n_t);

  tabulate_orders list(100);
  for (int i = 0; i < n_t; i++) {
    list.add_ord(x[i].order_);
  }
  list.pre_sort();
  for (int i = 0; i < n_t; i++) {
    list.tab_order(x[i].order_);
  }
  list.tab_print();

  if (to_print != 0) {
    printf("\nElements of order %d:\n\n", to_print);
    int c = 0;
    for (int i = 0; i < n_t; i++) {
      if (x[i].order_ == to_print) {
        printf("%d\n", ++c);
        print_mat(x[i].mat_);
        printf("\n");
      }
    }
  }

  if (print_all) {
    printf("\n");
    for (int i = 0; i < n_t; i++) {
      print_mat(x[i].mat_);
      printf("has order %d\n\n", x[i].order_);
    }
  }

  if (normalizer) {
    normalizer_test(p, x, n_t);
  }

  return 0;
}
