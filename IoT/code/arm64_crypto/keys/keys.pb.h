// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: keys.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_keys_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_keys_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_keys_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_keys_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_keys_2eproto;
class crypto_ecc_curve_message;
class crypto_ecc_curve_messageDefaultTypeInternal;
extern crypto_ecc_curve_messageDefaultTypeInternal _crypto_ecc_curve_message_default_instance_;
class crypto_ecc_key_message;
class crypto_ecc_key_messageDefaultTypeInternal;
extern crypto_ecc_key_messageDefaultTypeInternal _crypto_ecc_key_message_default_instance_;
class crypto_encryption_algorithm_message;
class crypto_encryption_algorithm_messageDefaultTypeInternal;
extern crypto_encryption_algorithm_messageDefaultTypeInternal _crypto_encryption_algorithm_message_default_instance_;
class crypto_key_message;
class crypto_key_messageDefaultTypeInternal;
extern crypto_key_messageDefaultTypeInternal _crypto_key_message_default_instance_;
class crypto_key_store_message;
class crypto_key_store_messageDefaultTypeInternal;
extern crypto_key_store_messageDefaultTypeInternal _crypto_key_store_message_default_instance_;
class crypto_point_message;
class crypto_point_messageDefaultTypeInternal;
extern crypto_point_messageDefaultTypeInternal _crypto_point_message_default_instance_;
class crypto_rsa_key_message;
class crypto_rsa_key_messageDefaultTypeInternal;
extern crypto_rsa_key_messageDefaultTypeInternal _crypto_rsa_key_message_default_instance_;
class crypto_signature;
class crypto_signatureDefaultTypeInternal;
extern crypto_signatureDefaultTypeInternal _crypto_signature_default_instance_;
class crypto_symmetric_key_message;
class crypto_symmetric_key_messageDefaultTypeInternal;
extern crypto_symmetric_key_messageDefaultTypeInternal _crypto_symmetric_key_message_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::crypto_ecc_curve_message* Arena::CreateMaybeMessage<::crypto_ecc_curve_message>(Arena*);
template<> ::crypto_ecc_key_message* Arena::CreateMaybeMessage<::crypto_ecc_key_message>(Arena*);
template<> ::crypto_encryption_algorithm_message* Arena::CreateMaybeMessage<::crypto_encryption_algorithm_message>(Arena*);
template<> ::crypto_key_message* Arena::CreateMaybeMessage<::crypto_key_message>(Arena*);
template<> ::crypto_key_store_message* Arena::CreateMaybeMessage<::crypto_key_store_message>(Arena*);
template<> ::crypto_point_message* Arena::CreateMaybeMessage<::crypto_point_message>(Arena*);
template<> ::crypto_rsa_key_message* Arena::CreateMaybeMessage<::crypto_rsa_key_message>(Arena*);
template<> ::crypto_signature* Arena::CreateMaybeMessage<::crypto_signature>(Arena*);
template<> ::crypto_symmetric_key_message* Arena::CreateMaybeMessage<::crypto_symmetric_key_message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class crypto_symmetric_key_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_symmetric_key_message) */ {
 public:
  crypto_symmetric_key_message();
  virtual ~crypto_symmetric_key_message();

  crypto_symmetric_key_message(const crypto_symmetric_key_message& from);
  crypto_symmetric_key_message(crypto_symmetric_key_message&& from) noexcept
    : crypto_symmetric_key_message() {
    *this = ::std::move(from);
  }

  inline crypto_symmetric_key_message& operator=(const crypto_symmetric_key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_symmetric_key_message& operator=(crypto_symmetric_key_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_symmetric_key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_symmetric_key_message* internal_default_instance() {
    return reinterpret_cast<const crypto_symmetric_key_message*>(
               &_crypto_symmetric_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(crypto_symmetric_key_message* other);
  friend void swap(crypto_symmetric_key_message& a, crypto_symmetric_key_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_symmetric_key_message* New() const final {
    return CreateMaybeMessage<crypto_symmetric_key_message>(nullptr);
  }

  crypto_symmetric_key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_symmetric_key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_symmetric_key_message& from);
  void MergeFrom(const crypto_symmetric_key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_symmetric_key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_symmetric_key_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key_type = 1;
  bool has_key_type() const;
  void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  const std::string& key_type() const;
  void set_key_type(const std::string& value);
  void set_key_type(std::string&& value);
  void set_key_type(const char* value);
  void set_key_type(const char* value, size_t size);
  std::string* mutable_key_type();
  std::string* release_key_type();
  void set_allocated_key_type(std::string* key_type);

  // optional string value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // optional int32 key_bit_size = 2;
  bool has_key_bit_size() const;
  void clear_key_bit_size();
  static const int kKeyBitSizeFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 key_bit_size() const;
  void set_key_bit_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:crypto_symmetric_key_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::int32 key_bit_size_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_rsa_key_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_rsa_key_message) */ {
 public:
  crypto_rsa_key_message();
  virtual ~crypto_rsa_key_message();

  crypto_rsa_key_message(const crypto_rsa_key_message& from);
  crypto_rsa_key_message(crypto_rsa_key_message&& from) noexcept
    : crypto_rsa_key_message() {
    *this = ::std::move(from);
  }

  inline crypto_rsa_key_message& operator=(const crypto_rsa_key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_rsa_key_message& operator=(crypto_rsa_key_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_rsa_key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_rsa_key_message* internal_default_instance() {
    return reinterpret_cast<const crypto_rsa_key_message*>(
               &_crypto_rsa_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(crypto_rsa_key_message* other);
  friend void swap(crypto_rsa_key_message& a, crypto_rsa_key_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_rsa_key_message* New() const final {
    return CreateMaybeMessage<crypto_rsa_key_message>(nullptr);
  }

  crypto_rsa_key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_rsa_key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_rsa_key_message& from);
  void MergeFrom(const crypto_rsa_key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_rsa_key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_rsa_key_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key_type = 1;
  bool has_key_type() const;
  void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  const std::string& key_type() const;
  void set_key_type(const std::string& value);
  void set_key_type(std::string&& value);
  void set_key_type(const char* value);
  void set_key_type(const char* value, size_t size);
  std::string* mutable_key_type();
  std::string* release_key_type();
  void set_allocated_key_type(std::string* key_type);

  // optional string modulus = 3;
  bool has_modulus() const;
  void clear_modulus();
  static const int kModulusFieldNumber = 3;
  const std::string& modulus() const;
  void set_modulus(const std::string& value);
  void set_modulus(std::string&& value);
  void set_modulus(const char* value);
  void set_modulus(const char* value, size_t size);
  std::string* mutable_modulus();
  std::string* release_modulus();
  void set_allocated_modulus(std::string* modulus);

  // optional string public_exponent = 4;
  bool has_public_exponent() const;
  void clear_public_exponent();
  static const int kPublicExponentFieldNumber = 4;
  const std::string& public_exponent() const;
  void set_public_exponent(const std::string& value);
  void set_public_exponent(std::string&& value);
  void set_public_exponent(const char* value);
  void set_public_exponent(const char* value, size_t size);
  std::string* mutable_public_exponent();
  std::string* release_public_exponent();
  void set_allocated_public_exponent(std::string* public_exponent);

  // optional string private_exponent = 5;
  bool has_private_exponent() const;
  void clear_private_exponent();
  static const int kPrivateExponentFieldNumber = 5;
  const std::string& private_exponent() const;
  void set_private_exponent(const std::string& value);
  void set_private_exponent(std::string&& value);
  void set_private_exponent(const char* value);
  void set_private_exponent(const char* value, size_t size);
  std::string* mutable_private_exponent();
  std::string* release_private_exponent();
  void set_allocated_private_exponent(std::string* private_exponent);

  // optional string p = 6;
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 6;
  const std::string& p() const;
  void set_p(const std::string& value);
  void set_p(std::string&& value);
  void set_p(const char* value);
  void set_p(const char* value, size_t size);
  std::string* mutable_p();
  std::string* release_p();
  void set_allocated_p(std::string* p);

  // optional string q = 7;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 7;
  const std::string& q() const;
  void set_q(const std::string& value);
  void set_q(std::string&& value);
  void set_q(const char* value);
  void set_q(const char* value, size_t size);
  std::string* mutable_q();
  std::string* release_q();
  void set_allocated_q(std::string* q);

  // optional string dp = 8;
  bool has_dp() const;
  void clear_dp();
  static const int kDpFieldNumber = 8;
  const std::string& dp() const;
  void set_dp(const std::string& value);
  void set_dp(std::string&& value);
  void set_dp(const char* value);
  void set_dp(const char* value, size_t size);
  std::string* mutable_dp();
  std::string* release_dp();
  void set_allocated_dp(std::string* dp);

  // optional string dq = 9;
  bool has_dq() const;
  void clear_dq();
  static const int kDqFieldNumber = 9;
  const std::string& dq() const;
  void set_dq(const std::string& value);
  void set_dq(std::string&& value);
  void set_dq(const char* value);
  void set_dq(const char* value, size_t size);
  std::string* mutable_dq();
  std::string* release_dq();
  void set_allocated_dq(std::string* dq);

  // optional string m_prime = 10;
  bool has_m_prime() const;
  void clear_m_prime();
  static const int kMPrimeFieldNumber = 10;
  const std::string& m_prime() const;
  void set_m_prime(const std::string& value);
  void set_m_prime(std::string&& value);
  void set_m_prime(const char* value);
  void set_m_prime(const char* value, size_t size);
  std::string* mutable_m_prime();
  std::string* release_m_prime();
  void set_allocated_m_prime(std::string* m_prime);

  // optional string p_prime = 11;
  bool has_p_prime() const;
  void clear_p_prime();
  static const int kPPrimeFieldNumber = 11;
  const std::string& p_prime() const;
  void set_p_prime(const std::string& value);
  void set_p_prime(std::string&& value);
  void set_p_prime(const char* value);
  void set_p_prime(const char* value, size_t size);
  std::string* mutable_p_prime();
  std::string* release_p_prime();
  void set_allocated_p_prime(std::string* p_prime);

  // optional string q_prime = 12;
  bool has_q_prime() const;
  void clear_q_prime();
  static const int kQPrimeFieldNumber = 12;
  const std::string& q_prime() const;
  void set_q_prime(const std::string& value);
  void set_q_prime(std::string&& value);
  void set_q_prime(const char* value);
  void set_q_prime(const char* value, size_t size);
  std::string* mutable_q_prime();
  std::string* release_q_prime();
  void set_allocated_q_prime(std::string* q_prime);

  // optional int32 key_bit_size = 2;
  bool has_key_bit_size() const;
  void clear_key_bit_size();
  static const int kKeyBitSizeFieldNumber = 2;
  ::PROTOBUF_NAMESPACE_ID::int32 key_bit_size() const;
  void set_key_bit_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:crypto_rsa_key_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modulus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr q_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dq_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_prime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_prime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr q_prime_;
  ::PROTOBUF_NAMESPACE_ID::int32 key_bit_size_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_ecc_curve_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_ecc_curve_message) */ {
 public:
  crypto_ecc_curve_message();
  virtual ~crypto_ecc_curve_message();

  crypto_ecc_curve_message(const crypto_ecc_curve_message& from);
  crypto_ecc_curve_message(crypto_ecc_curve_message&& from) noexcept
    : crypto_ecc_curve_message() {
    *this = ::std::move(from);
  }

  inline crypto_ecc_curve_message& operator=(const crypto_ecc_curve_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_ecc_curve_message& operator=(crypto_ecc_curve_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_ecc_curve_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_ecc_curve_message* internal_default_instance() {
    return reinterpret_cast<const crypto_ecc_curve_message*>(
               &_crypto_ecc_curve_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(crypto_ecc_curve_message* other);
  friend void swap(crypto_ecc_curve_message& a, crypto_ecc_curve_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_ecc_curve_message* New() const final {
    return CreateMaybeMessage<crypto_ecc_curve_message>(nullptr);
  }

  crypto_ecc_curve_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_ecc_curve_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_ecc_curve_message& from);
  void MergeFrom(const crypto_ecc_curve_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_ecc_curve_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_ecc_curve_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string p = 2;
  bool has_p() const;
  void clear_p();
  static const int kPFieldNumber = 2;
  const std::string& p() const;
  void set_p(const std::string& value);
  void set_p(std::string&& value);
  void set_p(const char* value);
  void set_p(const char* value, size_t size);
  std::string* mutable_p();
  std::string* release_p();
  void set_allocated_p(std::string* p);

  // optional string a = 3;
  bool has_a() const;
  void clear_a();
  static const int kAFieldNumber = 3;
  const std::string& a() const;
  void set_a(const std::string& value);
  void set_a(std::string&& value);
  void set_a(const char* value);
  void set_a(const char* value, size_t size);
  std::string* mutable_a();
  std::string* release_a();
  void set_allocated_a(std::string* a);

  // optional string b = 4;
  bool has_b() const;
  void clear_b();
  static const int kBFieldNumber = 4;
  const std::string& b() const;
  void set_b(const std::string& value);
  void set_b(std::string&& value);
  void set_b(const char* value);
  void set_b(const char* value, size_t size);
  std::string* mutable_b();
  std::string* release_b();
  void set_allocated_b(std::string* b);

  // required int32 bit_modulus_size = 1;
  bool has_bit_modulus_size() const;
  void clear_bit_modulus_size();
  static const int kBitModulusSizeFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 bit_modulus_size() const;
  void set_bit_modulus_size(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:crypto_ecc_curve_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
  ::PROTOBUF_NAMESPACE_ID::int32 bit_modulus_size_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_point_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_point_message) */ {
 public:
  crypto_point_message();
  virtual ~crypto_point_message();

  crypto_point_message(const crypto_point_message& from);
  crypto_point_message(crypto_point_message&& from) noexcept
    : crypto_point_message() {
    *this = ::std::move(from);
  }

  inline crypto_point_message& operator=(const crypto_point_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_point_message& operator=(crypto_point_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_point_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_point_message* internal_default_instance() {
    return reinterpret_cast<const crypto_point_message*>(
               &_crypto_point_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(crypto_point_message* other);
  friend void swap(crypto_point_message& a, crypto_point_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_point_message* New() const final {
    return CreateMaybeMessage<crypto_point_message>(nullptr);
  }

  crypto_point_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_point_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_point_message& from);
  void MergeFrom(const crypto_point_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_point_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_point_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  const std::string& x() const;
  void set_x(const std::string& value);
  void set_x(std::string&& value);
  void set_x(const char* value);
  void set_x(const char* value, size_t size);
  std::string* mutable_x();
  std::string* release_x();
  void set_allocated_x(std::string* x);

  // optional string y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  const std::string& y() const;
  void set_y(const std::string& value);
  void set_y(std::string&& value);
  void set_y(const char* value);
  void set_y(const char* value, size_t size);
  std::string* mutable_y();
  std::string* release_y();
  void set_allocated_y(std::string* y);

  // required int32 valid = 1;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 1;
  ::PROTOBUF_NAMESPACE_ID::int32 valid() const;
  void set_valid(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:crypto_point_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr y_;
  ::PROTOBUF_NAMESPACE_ID::int32 valid_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_ecc_key_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_ecc_key_message) */ {
 public:
  crypto_ecc_key_message();
  virtual ~crypto_ecc_key_message();

  crypto_ecc_key_message(const crypto_ecc_key_message& from);
  crypto_ecc_key_message(crypto_ecc_key_message&& from) noexcept
    : crypto_ecc_key_message() {
    *this = ::std::move(from);
  }

  inline crypto_ecc_key_message& operator=(const crypto_ecc_key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_ecc_key_message& operator=(crypto_ecc_key_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_ecc_key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_ecc_key_message* internal_default_instance() {
    return reinterpret_cast<const crypto_ecc_key_message*>(
               &_crypto_ecc_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(crypto_ecc_key_message* other);
  friend void swap(crypto_ecc_key_message& a, crypto_ecc_key_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_ecc_key_message* New() const final {
    return CreateMaybeMessage<crypto_ecc_key_message>(nullptr);
  }

  crypto_ecc_key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_ecc_key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_ecc_key_message& from);
  void MergeFrom(const crypto_ecc_key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_ecc_key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_ecc_key_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key_type = 1;
  bool has_key_type() const;
  void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  const std::string& key_type() const;
  void set_key_type(const std::string& value);
  void set_key_type(std::string&& value);
  void set_key_type(const char* value);
  void set_key_type(const char* value, size_t size);
  std::string* mutable_key_type();
  std::string* release_key_type();
  void set_allocated_key_type(std::string* key_type);

  // optional string private_nonce = 5;
  bool has_private_nonce() const;
  void clear_private_nonce();
  static const int kPrivateNonceFieldNumber = 5;
  const std::string& private_nonce() const;
  void set_private_nonce(const std::string& value);
  void set_private_nonce(std::string&& value);
  void set_private_nonce(const char* value);
  void set_private_nonce(const char* value, size_t size);
  std::string* mutable_private_nonce();
  std::string* release_private_nonce();
  void set_allocated_private_nonce(std::string* private_nonce);

  // optional string order = 6;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 6;
  const std::string& order() const;
  void set_order(const std::string& value);
  void set_order(std::string&& value);
  void set_order(const char* value);
  void set_order(const char* value, size_t size);
  std::string* mutable_order();
  std::string* release_order();
  void set_allocated_order(std::string* order);

  // optional .crypto_ecc_curve_message curve = 2;
  bool has_curve() const;
  void clear_curve();
  static const int kCurveFieldNumber = 2;
  const ::crypto_ecc_curve_message& curve() const;
  ::crypto_ecc_curve_message* release_curve();
  ::crypto_ecc_curve_message* mutable_curve();
  void set_allocated_curve(::crypto_ecc_curve_message* curve);

  // optional .crypto_point_message base_point = 3;
  bool has_base_point() const;
  void clear_base_point();
  static const int kBasePointFieldNumber = 3;
  const ::crypto_point_message& base_point() const;
  ::crypto_point_message* release_base_point();
  ::crypto_point_message* mutable_base_point();
  void set_allocated_base_point(::crypto_point_message* base_point);

  // optional .crypto_point_message generator = 4;
  bool has_generator() const;
  void clear_generator();
  static const int kGeneratorFieldNumber = 4;
  const ::crypto_point_message& generator() const;
  ::crypto_point_message* release_generator();
  ::crypto_point_message* mutable_generator();
  void set_allocated_generator(::crypto_point_message* generator);

  // @@protoc_insertion_point(class_scope:crypto_ecc_key_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_nonce_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_;
  ::crypto_ecc_curve_message* curve_;
  ::crypto_point_message* base_point_;
  ::crypto_point_message* generator_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_key_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_key_message) */ {
 public:
  crypto_key_message();
  virtual ~crypto_key_message();

  crypto_key_message(const crypto_key_message& from);
  crypto_key_message(crypto_key_message&& from) noexcept
    : crypto_key_message() {
    *this = ::std::move(from);
  }

  inline crypto_key_message& operator=(const crypto_key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_key_message& operator=(crypto_key_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_key_message* internal_default_instance() {
    return reinterpret_cast<const crypto_key_message*>(
               &_crypto_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(crypto_key_message* other);
  friend void swap(crypto_key_message& a, crypto_key_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_key_message* New() const final {
    return CreateMaybeMessage<crypto_key_message>(nullptr);
  }

  crypto_key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_key_message& from);
  void MergeFrom(const crypto_key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_key_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key_type = 1;
  bool has_key_type() const;
  void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  const std::string& key_type() const;
  void set_key_type(const std::string& value);
  void set_key_type(std::string&& value);
  void set_key_type(const char* value);
  void set_key_type(const char* value, size_t size);
  std::string* mutable_key_type();
  std::string* release_key_type();
  void set_allocated_key_type(std::string* key_type);

  // optional string key_name = 2;
  bool has_key_name() const;
  void clear_key_name();
  static const int kKeyNameFieldNumber = 2;
  const std::string& key_name() const;
  void set_key_name(const std::string& value);
  void set_key_name(std::string&& value);
  void set_key_name(const char* value);
  void set_key_name(const char* value, size_t size);
  std::string* mutable_key_name();
  std::string* release_key_name();
  void set_allocated_key_name(std::string* key_name);

  // optional string key_usage = 3;
  bool has_key_usage() const;
  void clear_key_usage();
  static const int kKeyUsageFieldNumber = 3;
  const std::string& key_usage() const;
  void set_key_usage(const std::string& value);
  void set_key_usage(std::string&& value);
  void set_key_usage(const char* value);
  void set_key_usage(const char* value, size_t size);
  std::string* mutable_key_usage();
  std::string* release_key_usage();
  void set_allocated_key_usage(std::string* key_usage);

  // optional string key_owner = 4;
  bool has_key_owner() const;
  void clear_key_owner();
  static const int kKeyOwnerFieldNumber = 4;
  const std::string& key_owner() const;
  void set_key_owner(const std::string& value);
  void set_key_owner(std::string&& value);
  void set_key_owner(const char* value);
  void set_key_owner(const char* value, size_t size);
  std::string* mutable_key_owner();
  std::string* release_key_owner();
  void set_allocated_key_owner(std::string* key_owner);

  // optional string not_before = 5;
  bool has_not_before() const;
  void clear_not_before();
  static const int kNotBeforeFieldNumber = 5;
  const std::string& not_before() const;
  void set_not_before(const std::string& value);
  void set_not_before(std::string&& value);
  void set_not_before(const char* value);
  void set_not_before(const char* value, size_t size);
  std::string* mutable_not_before();
  std::string* release_not_before();
  void set_allocated_not_before(std::string* not_before);

  // optional string not_after = 6;
  bool has_not_after() const;
  void clear_not_after();
  static const int kNotAfterFieldNumber = 6;
  const std::string& not_after() const;
  void set_not_after(const std::string& value);
  void set_not_after(std::string&& value);
  void set_not_after(const char* value);
  void set_not_after(const char* value, size_t size);
  std::string* mutable_not_after();
  std::string* release_not_after();
  void set_allocated_not_after(std::string* not_after);

  // optional string crypto_context = 10;
  bool has_crypto_context() const;
  void clear_crypto_context();
  static const int kCryptoContextFieldNumber = 10;
  const std::string& crypto_context() const;
  void set_crypto_context(const std::string& value);
  void set_crypto_context(std::string&& value);
  void set_crypto_context(const char* value);
  void set_crypto_context(const char* value, size_t size);
  std::string* mutable_crypto_context();
  std::string* release_crypto_context();
  void set_allocated_crypto_context(std::string* crypto_context);

  // optional .crypto_symmetric_key_message symkey = 7;
  bool has_symkey() const;
  void clear_symkey();
  static const int kSymkeyFieldNumber = 7;
  const ::crypto_symmetric_key_message& symkey() const;
  ::crypto_symmetric_key_message* release_symkey();
  ::crypto_symmetric_key_message* mutable_symkey();
  void set_allocated_symkey(::crypto_symmetric_key_message* symkey);

  // optional .crypto_rsa_key_message rsakey = 8;
  bool has_rsakey() const;
  void clear_rsakey();
  static const int kRsakeyFieldNumber = 8;
  const ::crypto_rsa_key_message& rsakey() const;
  ::crypto_rsa_key_message* release_rsakey();
  ::crypto_rsa_key_message* mutable_rsakey();
  void set_allocated_rsakey(::crypto_rsa_key_message* rsakey);

  // optional .crypto_ecc_key_message ecckey = 9;
  bool has_ecckey() const;
  void clear_ecckey();
  static const int kEcckeyFieldNumber = 9;
  const ::crypto_ecc_key_message& ecckey() const;
  ::crypto_ecc_key_message* release_ecckey();
  ::crypto_ecc_key_message* mutable_ecckey();
  void set_allocated_ecckey(::crypto_ecc_key_message* ecckey);

  // @@protoc_insertion_point(class_scope:crypto_key_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_usage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_before_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_after_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crypto_context_;
  ::crypto_symmetric_key_message* symkey_;
  ::crypto_rsa_key_message* rsakey_;
  ::crypto_ecc_key_message* ecckey_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_encryption_algorithm_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_encryption_algorithm_message) */ {
 public:
  crypto_encryption_algorithm_message();
  virtual ~crypto_encryption_algorithm_message();

  crypto_encryption_algorithm_message(const crypto_encryption_algorithm_message& from);
  crypto_encryption_algorithm_message(crypto_encryption_algorithm_message&& from) noexcept
    : crypto_encryption_algorithm_message() {
    *this = ::std::move(from);
  }

  inline crypto_encryption_algorithm_message& operator=(const crypto_encryption_algorithm_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_encryption_algorithm_message& operator=(crypto_encryption_algorithm_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_encryption_algorithm_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_encryption_algorithm_message* internal_default_instance() {
    return reinterpret_cast<const crypto_encryption_algorithm_message*>(
               &_crypto_encryption_algorithm_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(crypto_encryption_algorithm_message* other);
  friend void swap(crypto_encryption_algorithm_message& a, crypto_encryption_algorithm_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_encryption_algorithm_message* New() const final {
    return CreateMaybeMessage<crypto_encryption_algorithm_message>(nullptr);
  }

  crypto_encryption_algorithm_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_encryption_algorithm_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_encryption_algorithm_message& from);
  void MergeFrom(const crypto_encryption_algorithm_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_encryption_algorithm_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_encryption_algorithm_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string encryption_algorithm_name = 1;
  bool has_encryption_algorithm_name() const;
  void clear_encryption_algorithm_name();
  static const int kEncryptionAlgorithmNameFieldNumber = 1;
  const std::string& encryption_algorithm_name() const;
  void set_encryption_algorithm_name(const std::string& value);
  void set_encryption_algorithm_name(std::string&& value);
  void set_encryption_algorithm_name(const char* value);
  void set_encryption_algorithm_name(const char* value, size_t size);
  std::string* mutable_encryption_algorithm_name();
  std::string* release_encryption_algorithm_name();
  void set_allocated_encryption_algorithm_name(std::string* encryption_algorithm_name);

  // optional string message_id = 2;
  bool has_message_id() const;
  void clear_message_id();
  static const int kMessageIdFieldNumber = 2;
  const std::string& message_id() const;
  void set_message_id(const std::string& value);
  void set_message_id(std::string&& value);
  void set_message_id(const char* value);
  void set_message_id(const char* value, size_t size);
  std::string* mutable_message_id();
  std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);

  // optional string encryption_algorithm_hmac_key = 4;
  bool has_encryption_algorithm_hmac_key() const;
  void clear_encryption_algorithm_hmac_key();
  static const int kEncryptionAlgorithmHmacKeyFieldNumber = 4;
  const std::string& encryption_algorithm_hmac_key() const;
  void set_encryption_algorithm_hmac_key(const std::string& value);
  void set_encryption_algorithm_hmac_key(std::string&& value);
  void set_encryption_algorithm_hmac_key(const char* value);
  void set_encryption_algorithm_hmac_key(const char* value, size_t size);
  std::string* mutable_encryption_algorithm_hmac_key();
  std::string* release_encryption_algorithm_hmac_key();
  void set_allocated_encryption_algorithm_hmac_key(std::string* encryption_algorithm_hmac_key);

  // optional string encryption_algorithm_iv = 5;
  bool has_encryption_algorithm_iv() const;
  void clear_encryption_algorithm_iv();
  static const int kEncryptionAlgorithmIvFieldNumber = 5;
  const std::string& encryption_algorithm_iv() const;
  void set_encryption_algorithm_iv(const std::string& value);
  void set_encryption_algorithm_iv(std::string&& value);
  void set_encryption_algorithm_iv(const char* value);
  void set_encryption_algorithm_iv(const char* value, size_t size);
  std::string* mutable_encryption_algorithm_iv();
  std::string* release_encryption_algorithm_iv();
  void set_allocated_encryption_algorithm_iv(std::string* encryption_algorithm_iv);

  // optional string encryption_algorithm_mode = 6;
  bool has_encryption_algorithm_mode() const;
  void clear_encryption_algorithm_mode();
  static const int kEncryptionAlgorithmModeFieldNumber = 6;
  const std::string& encryption_algorithm_mode() const;
  void set_encryption_algorithm_mode(const std::string& value);
  void set_encryption_algorithm_mode(std::string&& value);
  void set_encryption_algorithm_mode(const char* value);
  void set_encryption_algorithm_mode(const char* value, size_t size);
  std::string* mutable_encryption_algorithm_mode();
  std::string* release_encryption_algorithm_mode();
  void set_allocated_encryption_algorithm_mode(std::string* encryption_algorithm_mode);

  // optional string encryption_algorithm_pad = 7;
  bool has_encryption_algorithm_pad() const;
  void clear_encryption_algorithm_pad();
  static const int kEncryptionAlgorithmPadFieldNumber = 7;
  const std::string& encryption_algorithm_pad() const;
  void set_encryption_algorithm_pad(const std::string& value);
  void set_encryption_algorithm_pad(std::string&& value);
  void set_encryption_algorithm_pad(const char* value);
  void set_encryption_algorithm_pad(const char* value, size_t size);
  std::string* mutable_encryption_algorithm_pad();
  std::string* release_encryption_algorithm_pad();
  void set_allocated_encryption_algorithm_pad(std::string* encryption_algorithm_pad);

  // optional .crypto_symmetric_key_message key_msg = 3;
  bool has_key_msg() const;
  void clear_key_msg();
  static const int kKeyMsgFieldNumber = 3;
  const ::crypto_symmetric_key_message& key_msg() const;
  ::crypto_symmetric_key_message* release_key_msg();
  ::crypto_symmetric_key_message* mutable_key_msg();
  void set_allocated_key_msg(::crypto_symmetric_key_message* key_msg);

  // @@protoc_insertion_point(class_scope:crypto_encryption_algorithm_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algorithm_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algorithm_hmac_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algorithm_iv_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algorithm_mode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algorithm_pad_;
  ::crypto_symmetric_key_message* key_msg_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_key_store_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_key_store_message) */ {
 public:
  crypto_key_store_message();
  virtual ~crypto_key_store_message();

  crypto_key_store_message(const crypto_key_store_message& from);
  crypto_key_store_message(crypto_key_store_message&& from) noexcept
    : crypto_key_store_message() {
    *this = ::std::move(from);
  }

  inline crypto_key_store_message& operator=(const crypto_key_store_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_key_store_message& operator=(crypto_key_store_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_key_store_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_key_store_message* internal_default_instance() {
    return reinterpret_cast<const crypto_key_store_message*>(
               &_crypto_key_store_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(crypto_key_store_message* other);
  friend void swap(crypto_key_store_message& a, crypto_key_store_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_key_store_message* New() const final {
    return CreateMaybeMessage<crypto_key_store_message>(nullptr);
  }

  crypto_key_store_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_key_store_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_key_store_message& from);
  void MergeFrom(const crypto_key_store_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_key_store_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_key_store_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .crypto_key_message key_entry = 1;
  int key_entry_size() const;
  void clear_key_entry();
  static const int kKeyEntryFieldNumber = 1;
  ::crypto_key_message* mutable_key_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto_key_message >*
      mutable_key_entry();
  const ::crypto_key_message& key_entry(int index) const;
  ::crypto_key_message* add_key_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto_key_message >&
      key_entry() const;

  // @@protoc_insertion_point(class_scope:crypto_key_store_message)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto_key_message > key_entry_;
  friend struct ::TableStruct_keys_2eproto;
};
// -------------------------------------------------------------------

class crypto_signature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto_signature) */ {
 public:
  crypto_signature();
  virtual ~crypto_signature();

  crypto_signature(const crypto_signature& from);
  crypto_signature(crypto_signature&& from) noexcept
    : crypto_signature() {
    *this = ::std::move(from);
  }

  inline crypto_signature& operator=(const crypto_signature& from) {
    CopyFrom(from);
    return *this;
  }
  inline crypto_signature& operator=(crypto_signature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const crypto_signature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const crypto_signature* internal_default_instance() {
    return reinterpret_cast<const crypto_signature*>(
               &_crypto_signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(crypto_signature* other);
  friend void swap(crypto_signature& a, crypto_signature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline crypto_signature* New() const final {
    return CreateMaybeMessage<crypto_signature>(nullptr);
  }

  crypto_signature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<crypto_signature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const crypto_signature& from);
  void MergeFrom(const crypto_signature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(crypto_signature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto_signature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_keys_2eproto);
    return ::descriptor_table_keys_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string encryption_algorithm_name = 1;
  bool has_encryption_algorithm_name() const;
  void clear_encryption_algorithm_name();
  static const int kEncryptionAlgorithmNameFieldNumber = 1;
  const std::string& encryption_algorithm_name() const;
  void set_encryption_algorithm_name(const std::string& value);
  void set_encryption_algorithm_name(std::string&& value);
  void set_encryption_algorithm_name(const char* value);
  void set_encryption_algorithm_name(const char* value, size_t size);
  std::string* mutable_encryption_algorithm_name();
  std::string* release_encryption_algorithm_name();
  void set_allocated_encryption_algorithm_name(std::string* encryption_algorithm_name);

  // required string serialized_statement = 2;
  bool has_serialized_statement() const;
  void clear_serialized_statement();
  static const int kSerializedStatementFieldNumber = 2;
  const std::string& serialized_statement() const;
  void set_serialized_statement(const std::string& value);
  void set_serialized_statement(std::string&& value);
  void set_serialized_statement(const char* value);
  void set_serialized_statement(const char* value, size_t size);
  std::string* mutable_serialized_statement();
  std::string* release_serialized_statement();
  void set_allocated_serialized_statement(std::string* serialized_statement);

  // optional string signature = 3;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);

  // optional string signer_name = 4;
  bool has_signer_name() const;
  void clear_signer_name();
  static const int kSignerNameFieldNumber = 4;
  const std::string& signer_name() const;
  void set_signer_name(const std::string& value);
  void set_signer_name(std::string&& value);
  void set_signer_name(const char* value);
  void set_signer_name(const char* value, size_t size);
  std::string* mutable_signer_name();
  std::string* release_signer_name();
  void set_allocated_signer_name(std::string* signer_name);

  // @@protoc_insertion_point(class_scope:crypto_signature)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_algorithm_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_statement_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signer_name_;
  friend struct ::TableStruct_keys_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// crypto_symmetric_key_message

// required string key_type = 1;
inline bool crypto_symmetric_key_message::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_symmetric_key_message::clear_key_type() {
  key_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_symmetric_key_message::key_type() const {
  // @@protoc_insertion_point(field_get:crypto_symmetric_key_message.key_type)
  return key_type_.GetNoArena();
}
inline void crypto_symmetric_key_message::set_key_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_symmetric_key_message.key_type)
}
inline void crypto_symmetric_key_message::set_key_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_symmetric_key_message.key_type)
}
inline void crypto_symmetric_key_message::set_key_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_symmetric_key_message.key_type)
}
inline void crypto_symmetric_key_message::set_key_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_symmetric_key_message.key_type)
}
inline std::string* crypto_symmetric_key_message::mutable_key_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_symmetric_key_message.key_type)
  return key_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_symmetric_key_message::release_key_type() {
  // @@protoc_insertion_point(field_release:crypto_symmetric_key_message.key_type)
  if (!has_key_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_symmetric_key_message::set_allocated_key_type(std::string* key_type) {
  if (key_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_type);
  // @@protoc_insertion_point(field_set_allocated:crypto_symmetric_key_message.key_type)
}

// optional int32 key_bit_size = 2;
inline bool crypto_symmetric_key_message::has_key_bit_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_symmetric_key_message::clear_key_bit_size() {
  key_bit_size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 crypto_symmetric_key_message::key_bit_size() const {
  // @@protoc_insertion_point(field_get:crypto_symmetric_key_message.key_bit_size)
  return key_bit_size_;
}
inline void crypto_symmetric_key_message::set_key_bit_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  key_bit_size_ = value;
  // @@protoc_insertion_point(field_set:crypto_symmetric_key_message.key_bit_size)
}

// optional string value = 3;
inline bool crypto_symmetric_key_message::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_symmetric_key_message::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_symmetric_key_message::value() const {
  // @@protoc_insertion_point(field_get:crypto_symmetric_key_message.value)
  return value_.GetNoArena();
}
inline void crypto_symmetric_key_message::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_symmetric_key_message.value)
}
inline void crypto_symmetric_key_message::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_symmetric_key_message.value)
}
inline void crypto_symmetric_key_message::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_symmetric_key_message.value)
}
inline void crypto_symmetric_key_message::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_symmetric_key_message.value)
}
inline std::string* crypto_symmetric_key_message::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_symmetric_key_message.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_symmetric_key_message::release_value() {
  // @@protoc_insertion_point(field_release:crypto_symmetric_key_message.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_symmetric_key_message::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:crypto_symmetric_key_message.value)
}

// -------------------------------------------------------------------

// crypto_rsa_key_message

// required string key_type = 1;
inline bool crypto_rsa_key_message::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_rsa_key_message::clear_key_type() {
  key_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_rsa_key_message::key_type() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.key_type)
  return key_type_.GetNoArena();
}
inline void crypto_rsa_key_message::set_key_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.key_type)
}
inline void crypto_rsa_key_message::set_key_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.key_type)
}
inline void crypto_rsa_key_message::set_key_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.key_type)
}
inline void crypto_rsa_key_message::set_key_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.key_type)
}
inline std::string* crypto_rsa_key_message::mutable_key_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.key_type)
  return key_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_key_type() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.key_type)
  if (!has_key_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_key_type(std::string* key_type) {
  if (key_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_type);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.key_type)
}

// optional int32 key_bit_size = 2;
inline bool crypto_rsa_key_message::has_key_bit_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void crypto_rsa_key_message::clear_key_bit_size() {
  key_bit_size_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 crypto_rsa_key_message::key_bit_size() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.key_bit_size)
  return key_bit_size_;
}
inline void crypto_rsa_key_message::set_key_bit_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  key_bit_size_ = value;
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.key_bit_size)
}

// optional string modulus = 3;
inline bool crypto_rsa_key_message::has_modulus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_rsa_key_message::clear_modulus() {
  modulus_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_rsa_key_message::modulus() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.modulus)
  return modulus_.GetNoArena();
}
inline void crypto_rsa_key_message::set_modulus(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  modulus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.modulus)
}
inline void crypto_rsa_key_message::set_modulus(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  modulus_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.modulus)
}
inline void crypto_rsa_key_message::set_modulus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  modulus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.modulus)
}
inline void crypto_rsa_key_message::set_modulus(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  modulus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.modulus)
}
inline std::string* crypto_rsa_key_message::mutable_modulus() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.modulus)
  return modulus_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_modulus() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.modulus)
  if (!has_modulus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return modulus_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_modulus(std::string* modulus) {
  if (modulus != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  modulus_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modulus);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.modulus)
}

// optional string public_exponent = 4;
inline bool crypto_rsa_key_message::has_public_exponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_rsa_key_message::clear_public_exponent() {
  public_exponent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& crypto_rsa_key_message::public_exponent() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.public_exponent)
  return public_exponent_.GetNoArena();
}
inline void crypto_rsa_key_message::set_public_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  public_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.public_exponent)
}
inline void crypto_rsa_key_message::set_public_exponent(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  public_exponent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.public_exponent)
}
inline void crypto_rsa_key_message::set_public_exponent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  public_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.public_exponent)
}
inline void crypto_rsa_key_message::set_public_exponent(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  public_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.public_exponent)
}
inline std::string* crypto_rsa_key_message::mutable_public_exponent() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.public_exponent)
  return public_exponent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_public_exponent() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.public_exponent)
  if (!has_public_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return public_exponent_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_public_exponent(std::string* public_exponent) {
  if (public_exponent != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_exponent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_exponent);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.public_exponent)
}

// optional string private_exponent = 5;
inline bool crypto_rsa_key_message::has_private_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void crypto_rsa_key_message::clear_private_exponent() {
  private_exponent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& crypto_rsa_key_message::private_exponent() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.private_exponent)
  return private_exponent_.GetNoArena();
}
inline void crypto_rsa_key_message::set_private_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  private_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.private_exponent)
}
inline void crypto_rsa_key_message::set_private_exponent(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  private_exponent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.private_exponent)
}
inline void crypto_rsa_key_message::set_private_exponent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  private_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.private_exponent)
}
inline void crypto_rsa_key_message::set_private_exponent(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  private_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.private_exponent)
}
inline std::string* crypto_rsa_key_message::mutable_private_exponent() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.private_exponent)
  return private_exponent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_private_exponent() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.private_exponent)
  if (!has_private_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return private_exponent_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_private_exponent(std::string* private_exponent) {
  if (private_exponent != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  private_exponent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_exponent);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.private_exponent)
}

// optional string p = 6;
inline bool crypto_rsa_key_message::has_p() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void crypto_rsa_key_message::clear_p() {
  p_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& crypto_rsa_key_message::p() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.p)
  return p_.GetNoArena();
}
inline void crypto_rsa_key_message::set_p(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.p)
}
inline void crypto_rsa_key_message::set_p(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  p_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.p)
}
inline void crypto_rsa_key_message::set_p(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.p)
}
inline void crypto_rsa_key_message::set_p(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.p)
}
inline std::string* crypto_rsa_key_message::mutable_p() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.p)
  return p_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_p() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.p)
  if (!has_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return p_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_p(std::string* p) {
  if (p != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  p_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.p)
}

// optional string q = 7;
inline bool crypto_rsa_key_message::has_q() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void crypto_rsa_key_message::clear_q() {
  q_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& crypto_rsa_key_message::q() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.q)
  return q_.GetNoArena();
}
inline void crypto_rsa_key_message::set_q(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  q_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.q)
}
inline void crypto_rsa_key_message::set_q(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  q_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.q)
}
inline void crypto_rsa_key_message::set_q(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  q_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.q)
}
inline void crypto_rsa_key_message::set_q(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  q_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.q)
}
inline std::string* crypto_rsa_key_message::mutable_q() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.q)
  return q_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_q() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.q)
  if (!has_q()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return q_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_q(std::string* q) {
  if (q != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  q_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), q);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.q)
}

// optional string dp = 8;
inline bool crypto_rsa_key_message::has_dp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void crypto_rsa_key_message::clear_dp() {
  dp_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& crypto_rsa_key_message::dp() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.dp)
  return dp_.GetNoArena();
}
inline void crypto_rsa_key_message::set_dp(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  dp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.dp)
}
inline void crypto_rsa_key_message::set_dp(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  dp_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.dp)
}
inline void crypto_rsa_key_message::set_dp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  dp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.dp)
}
inline void crypto_rsa_key_message::set_dp(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  dp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.dp)
}
inline std::string* crypto_rsa_key_message::mutable_dp() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.dp)
  return dp_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_dp() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.dp)
  if (!has_dp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return dp_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_dp(std::string* dp) {
  if (dp != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  dp_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dp);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.dp)
}

// optional string dq = 9;
inline bool crypto_rsa_key_message::has_dq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void crypto_rsa_key_message::clear_dq() {
  dq_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& crypto_rsa_key_message::dq() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.dq)
  return dq_.GetNoArena();
}
inline void crypto_rsa_key_message::set_dq(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  dq_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.dq)
}
inline void crypto_rsa_key_message::set_dq(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  dq_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.dq)
}
inline void crypto_rsa_key_message::set_dq(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  dq_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.dq)
}
inline void crypto_rsa_key_message::set_dq(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  dq_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.dq)
}
inline std::string* crypto_rsa_key_message::mutable_dq() {
  _has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.dq)
  return dq_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_dq() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.dq)
  if (!has_dq()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return dq_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_dq(std::string* dq) {
  if (dq != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  dq_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dq);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.dq)
}

// optional string m_prime = 10;
inline bool crypto_rsa_key_message::has_m_prime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void crypto_rsa_key_message::clear_m_prime() {
  m_prime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& crypto_rsa_key_message::m_prime() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.m_prime)
  return m_prime_.GetNoArena();
}
inline void crypto_rsa_key_message::set_m_prime(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  m_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.m_prime)
}
inline void crypto_rsa_key_message::set_m_prime(std::string&& value) {
  _has_bits_[0] |= 0x00000100u;
  m_prime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.m_prime)
}
inline void crypto_rsa_key_message::set_m_prime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000100u;
  m_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.m_prime)
}
inline void crypto_rsa_key_message::set_m_prime(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000100u;
  m_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.m_prime)
}
inline std::string* crypto_rsa_key_message::mutable_m_prime() {
  _has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.m_prime)
  return m_prime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_m_prime() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.m_prime)
  if (!has_m_prime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return m_prime_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_m_prime(std::string* m_prime) {
  if (m_prime != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  m_prime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), m_prime);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.m_prime)
}

// optional string p_prime = 11;
inline bool crypto_rsa_key_message::has_p_prime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void crypto_rsa_key_message::clear_p_prime() {
  p_prime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& crypto_rsa_key_message::p_prime() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.p_prime)
  return p_prime_.GetNoArena();
}
inline void crypto_rsa_key_message::set_p_prime(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  p_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.p_prime)
}
inline void crypto_rsa_key_message::set_p_prime(std::string&& value) {
  _has_bits_[0] |= 0x00000200u;
  p_prime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.p_prime)
}
inline void crypto_rsa_key_message::set_p_prime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000200u;
  p_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.p_prime)
}
inline void crypto_rsa_key_message::set_p_prime(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000200u;
  p_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.p_prime)
}
inline std::string* crypto_rsa_key_message::mutable_p_prime() {
  _has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.p_prime)
  return p_prime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_p_prime() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.p_prime)
  if (!has_p_prime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return p_prime_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_p_prime(std::string* p_prime) {
  if (p_prime != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  p_prime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p_prime);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.p_prime)
}

// optional string q_prime = 12;
inline bool crypto_rsa_key_message::has_q_prime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void crypto_rsa_key_message::clear_q_prime() {
  q_prime_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& crypto_rsa_key_message::q_prime() const {
  // @@protoc_insertion_point(field_get:crypto_rsa_key_message.q_prime)
  return q_prime_.GetNoArena();
}
inline void crypto_rsa_key_message::set_q_prime(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  q_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_rsa_key_message.q_prime)
}
inline void crypto_rsa_key_message::set_q_prime(std::string&& value) {
  _has_bits_[0] |= 0x00000400u;
  q_prime_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_rsa_key_message.q_prime)
}
inline void crypto_rsa_key_message::set_q_prime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000400u;
  q_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_rsa_key_message.q_prime)
}
inline void crypto_rsa_key_message::set_q_prime(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000400u;
  q_prime_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_rsa_key_message.q_prime)
}
inline std::string* crypto_rsa_key_message::mutable_q_prime() {
  _has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_mutable:crypto_rsa_key_message.q_prime)
  return q_prime_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_rsa_key_message::release_q_prime() {
  // @@protoc_insertion_point(field_release:crypto_rsa_key_message.q_prime)
  if (!has_q_prime()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return q_prime_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_rsa_key_message::set_allocated_q_prime(std::string* q_prime) {
  if (q_prime != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  q_prime_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), q_prime);
  // @@protoc_insertion_point(field_set_allocated:crypto_rsa_key_message.q_prime)
}

// -------------------------------------------------------------------

// crypto_ecc_curve_message

// required int32 bit_modulus_size = 1;
inline bool crypto_ecc_curve_message::has_bit_modulus_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void crypto_ecc_curve_message::clear_bit_modulus_size() {
  bit_modulus_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 crypto_ecc_curve_message::bit_modulus_size() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_curve_message.bit_modulus_size)
  return bit_modulus_size_;
}
inline void crypto_ecc_curve_message::set_bit_modulus_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  bit_modulus_size_ = value;
  // @@protoc_insertion_point(field_set:crypto_ecc_curve_message.bit_modulus_size)
}

// optional string p = 2;
inline bool crypto_ecc_curve_message::has_p() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_ecc_curve_message::clear_p() {
  p_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_ecc_curve_message::p() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_curve_message.p)
  return p_.GetNoArena();
}
inline void crypto_ecc_curve_message::set_p(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_ecc_curve_message.p)
}
inline void crypto_ecc_curve_message::set_p(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  p_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_ecc_curve_message.p)
}
inline void crypto_ecc_curve_message::set_p(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_ecc_curve_message.p)
}
inline void crypto_ecc_curve_message::set_p(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_ecc_curve_message.p)
}
inline std::string* crypto_ecc_curve_message::mutable_p() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_ecc_curve_message.p)
  return p_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_ecc_curve_message::release_p() {
  // @@protoc_insertion_point(field_release:crypto_ecc_curve_message.p)
  if (!has_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return p_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_ecc_curve_message::set_allocated_p(std::string* p) {
  if (p != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  p_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p);
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_curve_message.p)
}

// optional string a = 3;
inline bool crypto_ecc_curve_message::has_a() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_ecc_curve_message::clear_a() {
  a_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_ecc_curve_message::a() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_curve_message.a)
  return a_.GetNoArena();
}
inline void crypto_ecc_curve_message::set_a(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  a_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_ecc_curve_message.a)
}
inline void crypto_ecc_curve_message::set_a(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  a_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_ecc_curve_message.a)
}
inline void crypto_ecc_curve_message::set_a(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  a_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_ecc_curve_message.a)
}
inline void crypto_ecc_curve_message::set_a(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  a_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_ecc_curve_message.a)
}
inline std::string* crypto_ecc_curve_message::mutable_a() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_ecc_curve_message.a)
  return a_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_ecc_curve_message::release_a() {
  // @@protoc_insertion_point(field_release:crypto_ecc_curve_message.a)
  if (!has_a()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return a_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_ecc_curve_message::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  a_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), a);
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_curve_message.a)
}

// optional string b = 4;
inline bool crypto_ecc_curve_message::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_ecc_curve_message::clear_b() {
  b_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& crypto_ecc_curve_message::b() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_curve_message.b)
  return b_.GetNoArena();
}
inline void crypto_ecc_curve_message::set_b(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_ecc_curve_message.b)
}
inline void crypto_ecc_curve_message::set_b(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  b_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_ecc_curve_message.b)
}
inline void crypto_ecc_curve_message::set_b(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_ecc_curve_message.b)
}
inline void crypto_ecc_curve_message::set_b(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_ecc_curve_message.b)
}
inline std::string* crypto_ecc_curve_message::mutable_b() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:crypto_ecc_curve_message.b)
  return b_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_ecc_curve_message::release_b() {
  // @@protoc_insertion_point(field_release:crypto_ecc_curve_message.b)
  if (!has_b()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return b_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_ecc_curve_message::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  b_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), b);
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_curve_message.b)
}

// -------------------------------------------------------------------

// crypto_point_message

// required int32 valid = 1;
inline bool crypto_point_message::has_valid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_point_message::clear_valid() {
  valid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 crypto_point_message::valid() const {
  // @@protoc_insertion_point(field_get:crypto_point_message.valid)
  return valid_;
}
inline void crypto_point_message::set_valid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  valid_ = value;
  // @@protoc_insertion_point(field_set:crypto_point_message.valid)
}

// optional string x = 2;
inline bool crypto_point_message::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_point_message::clear_x() {
  x_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_point_message::x() const {
  // @@protoc_insertion_point(field_get:crypto_point_message.x)
  return x_.GetNoArena();
}
inline void crypto_point_message::set_x(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_point_message.x)
}
inline void crypto_point_message::set_x(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_point_message.x)
}
inline void crypto_point_message::set_x(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_point_message.x)
}
inline void crypto_point_message::set_x(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_point_message.x)
}
inline std::string* crypto_point_message::mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_point_message.x)
  return x_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_point_message::release_x() {
  // @@protoc_insertion_point(field_release:crypto_point_message.x)
  if (!has_x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return x_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_point_message::set_allocated_x(std::string* x) {
  if (x != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:crypto_point_message.x)
}

// optional string y = 3;
inline bool crypto_point_message::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_point_message::clear_y() {
  y_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_point_message::y() const {
  // @@protoc_insertion_point(field_get:crypto_point_message.y)
  return y_.GetNoArena();
}
inline void crypto_point_message::set_y(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_point_message.y)
}
inline void crypto_point_message::set_y(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_point_message.y)
}
inline void crypto_point_message::set_y(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_point_message.y)
}
inline void crypto_point_message::set_y(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_point_message.y)
}
inline std::string* crypto_point_message::mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_point_message.y)
  return y_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_point_message::release_y() {
  // @@protoc_insertion_point(field_release:crypto_point_message.y)
  if (!has_y()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return y_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_point_message::set_allocated_y(std::string* y) {
  if (y != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:crypto_point_message.y)
}

// -------------------------------------------------------------------

// crypto_ecc_key_message

// required string key_type = 1;
inline bool crypto_ecc_key_message::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_ecc_key_message::clear_key_type() {
  key_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_ecc_key_message::key_type() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_key_message.key_type)
  return key_type_.GetNoArena();
}
inline void crypto_ecc_key_message::set_key_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_ecc_key_message.key_type)
}
inline void crypto_ecc_key_message::set_key_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_ecc_key_message.key_type)
}
inline void crypto_ecc_key_message::set_key_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_ecc_key_message.key_type)
}
inline void crypto_ecc_key_message::set_key_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_ecc_key_message.key_type)
}
inline std::string* crypto_ecc_key_message::mutable_key_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_ecc_key_message.key_type)
  return key_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_ecc_key_message::release_key_type() {
  // @@protoc_insertion_point(field_release:crypto_ecc_key_message.key_type)
  if (!has_key_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_ecc_key_message::set_allocated_key_type(std::string* key_type) {
  if (key_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_type);
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_key_message.key_type)
}

// optional .crypto_ecc_curve_message curve = 2;
inline bool crypto_ecc_key_message::has_curve() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void crypto_ecc_key_message::clear_curve() {
  if (curve_ != nullptr) curve_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::crypto_ecc_curve_message& crypto_ecc_key_message::curve() const {
  const ::crypto_ecc_curve_message* p = curve_;
  // @@protoc_insertion_point(field_get:crypto_ecc_key_message.curve)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_ecc_curve_message*>(
      &::_crypto_ecc_curve_message_default_instance_);
}
inline ::crypto_ecc_curve_message* crypto_ecc_key_message::release_curve() {
  // @@protoc_insertion_point(field_release:crypto_ecc_key_message.curve)
  _has_bits_[0] &= ~0x00000008u;
  ::crypto_ecc_curve_message* temp = curve_;
  curve_ = nullptr;
  return temp;
}
inline ::crypto_ecc_curve_message* crypto_ecc_key_message::mutable_curve() {
  _has_bits_[0] |= 0x00000008u;
  if (curve_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_ecc_curve_message>(GetArenaNoVirtual());
    curve_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_ecc_key_message.curve)
  return curve_;
}
inline void crypto_ecc_key_message::set_allocated_curve(::crypto_ecc_curve_message* curve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete curve_;
  }
  if (curve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      curve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, curve, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  curve_ = curve;
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_key_message.curve)
}

// optional .crypto_point_message base_point = 3;
inline bool crypto_ecc_key_message::has_base_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void crypto_ecc_key_message::clear_base_point() {
  if (base_point_ != nullptr) base_point_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::crypto_point_message& crypto_ecc_key_message::base_point() const {
  const ::crypto_point_message* p = base_point_;
  // @@protoc_insertion_point(field_get:crypto_ecc_key_message.base_point)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_point_message*>(
      &::_crypto_point_message_default_instance_);
}
inline ::crypto_point_message* crypto_ecc_key_message::release_base_point() {
  // @@protoc_insertion_point(field_release:crypto_ecc_key_message.base_point)
  _has_bits_[0] &= ~0x00000010u;
  ::crypto_point_message* temp = base_point_;
  base_point_ = nullptr;
  return temp;
}
inline ::crypto_point_message* crypto_ecc_key_message::mutable_base_point() {
  _has_bits_[0] |= 0x00000010u;
  if (base_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_point_message>(GetArenaNoVirtual());
    base_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_ecc_key_message.base_point)
  return base_point_;
}
inline void crypto_ecc_key_message::set_allocated_base_point(::crypto_point_message* base_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete base_point_;
  }
  if (base_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  base_point_ = base_point;
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_key_message.base_point)
}

// optional .crypto_point_message generator = 4;
inline bool crypto_ecc_key_message::has_generator() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void crypto_ecc_key_message::clear_generator() {
  if (generator_ != nullptr) generator_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::crypto_point_message& crypto_ecc_key_message::generator() const {
  const ::crypto_point_message* p = generator_;
  // @@protoc_insertion_point(field_get:crypto_ecc_key_message.generator)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_point_message*>(
      &::_crypto_point_message_default_instance_);
}
inline ::crypto_point_message* crypto_ecc_key_message::release_generator() {
  // @@protoc_insertion_point(field_release:crypto_ecc_key_message.generator)
  _has_bits_[0] &= ~0x00000020u;
  ::crypto_point_message* temp = generator_;
  generator_ = nullptr;
  return temp;
}
inline ::crypto_point_message* crypto_ecc_key_message::mutable_generator() {
  _has_bits_[0] |= 0x00000020u;
  if (generator_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_point_message>(GetArenaNoVirtual());
    generator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_ecc_key_message.generator)
  return generator_;
}
inline void crypto_ecc_key_message::set_allocated_generator(::crypto_point_message* generator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete generator_;
  }
  if (generator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      generator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generator, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  generator_ = generator;
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_key_message.generator)
}

// optional string private_nonce = 5;
inline bool crypto_ecc_key_message::has_private_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_ecc_key_message::clear_private_nonce() {
  private_nonce_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_ecc_key_message::private_nonce() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_key_message.private_nonce)
  return private_nonce_.GetNoArena();
}
inline void crypto_ecc_key_message::set_private_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  private_nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_ecc_key_message.private_nonce)
}
inline void crypto_ecc_key_message::set_private_nonce(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  private_nonce_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_ecc_key_message.private_nonce)
}
inline void crypto_ecc_key_message::set_private_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  private_nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_ecc_key_message.private_nonce)
}
inline void crypto_ecc_key_message::set_private_nonce(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  private_nonce_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_ecc_key_message.private_nonce)
}
inline std::string* crypto_ecc_key_message::mutable_private_nonce() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_ecc_key_message.private_nonce)
  return private_nonce_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_ecc_key_message::release_private_nonce() {
  // @@protoc_insertion_point(field_release:crypto_ecc_key_message.private_nonce)
  if (!has_private_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return private_nonce_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_ecc_key_message::set_allocated_private_nonce(std::string* private_nonce) {
  if (private_nonce != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  private_nonce_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_nonce);
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_key_message.private_nonce)
}

// optional string order = 6;
inline bool crypto_ecc_key_message::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_ecc_key_message::clear_order() {
  order_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& crypto_ecc_key_message::order() const {
  // @@protoc_insertion_point(field_get:crypto_ecc_key_message.order)
  return order_.GetNoArena();
}
inline void crypto_ecc_key_message::set_order(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  order_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_ecc_key_message.order)
}
inline void crypto_ecc_key_message::set_order(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  order_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_ecc_key_message.order)
}
inline void crypto_ecc_key_message::set_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  order_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_ecc_key_message.order)
}
inline void crypto_ecc_key_message::set_order(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  order_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_ecc_key_message.order)
}
inline std::string* crypto_ecc_key_message::mutable_order() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:crypto_ecc_key_message.order)
  return order_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_ecc_key_message::release_order() {
  // @@protoc_insertion_point(field_release:crypto_ecc_key_message.order)
  if (!has_order()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return order_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_ecc_key_message::set_allocated_order(std::string* order) {
  if (order != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  order_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order);
  // @@protoc_insertion_point(field_set_allocated:crypto_ecc_key_message.order)
}

// -------------------------------------------------------------------

// crypto_key_message

// required string key_type = 1;
inline bool crypto_key_message::has_key_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_key_message::clear_key_type() {
  key_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_key_message::key_type() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.key_type)
  return key_type_.GetNoArena();
}
inline void crypto_key_message::set_key_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.key_type)
}
inline void crypto_key_message::set_key_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.key_type)
}
inline void crypto_key_message::set_key_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.key_type)
}
inline void crypto_key_message::set_key_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.key_type)
}
inline std::string* crypto_key_message::mutable_key_type() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.key_type)
  return key_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_key_type() {
  // @@protoc_insertion_point(field_release:crypto_key_message.key_type)
  if (!has_key_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_key_type(std::string* key_type) {
  if (key_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_type);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.key_type)
}

// optional string key_name = 2;
inline bool crypto_key_message::has_key_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_key_message::clear_key_name() {
  key_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_key_message::key_name() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.key_name)
  return key_name_.GetNoArena();
}
inline void crypto_key_message::set_key_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.key_name)
}
inline void crypto_key_message::set_key_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.key_name)
}
inline void crypto_key_message::set_key_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.key_name)
}
inline void crypto_key_message::set_key_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.key_name)
}
inline std::string* crypto_key_message::mutable_key_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.key_name)
  return key_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_key_name() {
  // @@protoc_insertion_point(field_release:crypto_key_message.key_name)
  if (!has_key_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_key_name(std::string* key_name) {
  if (key_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_name);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.key_name)
}

// optional string key_usage = 3;
inline bool crypto_key_message::has_key_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_key_message::clear_key_usage() {
  key_usage_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& crypto_key_message::key_usage() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.key_usage)
  return key_usage_.GetNoArena();
}
inline void crypto_key_message::set_key_usage(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  key_usage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.key_usage)
}
inline void crypto_key_message::set_key_usage(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  key_usage_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.key_usage)
}
inline void crypto_key_message::set_key_usage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  key_usage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.key_usage)
}
inline void crypto_key_message::set_key_usage(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  key_usage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.key_usage)
}
inline std::string* crypto_key_message::mutable_key_usage() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.key_usage)
  return key_usage_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_key_usage() {
  // @@protoc_insertion_point(field_release:crypto_key_message.key_usage)
  if (!has_key_usage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return key_usage_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_key_usage(std::string* key_usage) {
  if (key_usage != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_usage_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_usage);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.key_usage)
}

// optional string key_owner = 4;
inline bool crypto_key_message::has_key_owner() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void crypto_key_message::clear_key_owner() {
  key_owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& crypto_key_message::key_owner() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.key_owner)
  return key_owner_.GetNoArena();
}
inline void crypto_key_message::set_key_owner(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  key_owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.key_owner)
}
inline void crypto_key_message::set_key_owner(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  key_owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.key_owner)
}
inline void crypto_key_message::set_key_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  key_owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.key_owner)
}
inline void crypto_key_message::set_key_owner(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  key_owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.key_owner)
}
inline std::string* crypto_key_message::mutable_key_owner() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.key_owner)
  return key_owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_key_owner() {
  // @@protoc_insertion_point(field_release:crypto_key_message.key_owner)
  if (!has_key_owner()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return key_owner_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_key_owner(std::string* key_owner) {
  if (key_owner != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  key_owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_owner);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.key_owner)
}

// optional string not_before = 5;
inline bool crypto_key_message::has_not_before() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void crypto_key_message::clear_not_before() {
  not_before_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& crypto_key_message::not_before() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.not_before)
  return not_before_.GetNoArena();
}
inline void crypto_key_message::set_not_before(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.not_before)
}
inline void crypto_key_message::set_not_before(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  not_before_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.not_before)
}
inline void crypto_key_message::set_not_before(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.not_before)
}
inline void crypto_key_message::set_not_before(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.not_before)
}
inline std::string* crypto_key_message::mutable_not_before() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.not_before)
  return not_before_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_not_before() {
  // @@protoc_insertion_point(field_release:crypto_key_message.not_before)
  if (!has_not_before()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return not_before_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_not_before(std::string* not_before) {
  if (not_before != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  not_before_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_before);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.not_before)
}

// optional string not_after = 6;
inline bool crypto_key_message::has_not_after() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void crypto_key_message::clear_not_after() {
  not_after_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& crypto_key_message::not_after() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.not_after)
  return not_after_.GetNoArena();
}
inline void crypto_key_message::set_not_after(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.not_after)
}
inline void crypto_key_message::set_not_after(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  not_after_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.not_after)
}
inline void crypto_key_message::set_not_after(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.not_after)
}
inline void crypto_key_message::set_not_after(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.not_after)
}
inline std::string* crypto_key_message::mutable_not_after() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.not_after)
  return not_after_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_not_after() {
  // @@protoc_insertion_point(field_release:crypto_key_message.not_after)
  if (!has_not_after()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return not_after_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_not_after(std::string* not_after) {
  if (not_after != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  not_after_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_after);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.not_after)
}

// optional .crypto_symmetric_key_message symkey = 7;
inline bool crypto_key_message::has_symkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void crypto_key_message::clear_symkey() {
  if (symkey_ != nullptr) symkey_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::crypto_symmetric_key_message& crypto_key_message::symkey() const {
  const ::crypto_symmetric_key_message* p = symkey_;
  // @@protoc_insertion_point(field_get:crypto_key_message.symkey)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_symmetric_key_message*>(
      &::_crypto_symmetric_key_message_default_instance_);
}
inline ::crypto_symmetric_key_message* crypto_key_message::release_symkey() {
  // @@protoc_insertion_point(field_release:crypto_key_message.symkey)
  _has_bits_[0] &= ~0x00000080u;
  ::crypto_symmetric_key_message* temp = symkey_;
  symkey_ = nullptr;
  return temp;
}
inline ::crypto_symmetric_key_message* crypto_key_message::mutable_symkey() {
  _has_bits_[0] |= 0x00000080u;
  if (symkey_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_symmetric_key_message>(GetArenaNoVirtual());
    symkey_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_key_message.symkey)
  return symkey_;
}
inline void crypto_key_message::set_allocated_symkey(::crypto_symmetric_key_message* symkey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete symkey_;
  }
  if (symkey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      symkey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, symkey, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  symkey_ = symkey;
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.symkey)
}

// optional .crypto_rsa_key_message rsakey = 8;
inline bool crypto_key_message::has_rsakey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void crypto_key_message::clear_rsakey() {
  if (rsakey_ != nullptr) rsakey_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::crypto_rsa_key_message& crypto_key_message::rsakey() const {
  const ::crypto_rsa_key_message* p = rsakey_;
  // @@protoc_insertion_point(field_get:crypto_key_message.rsakey)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_rsa_key_message*>(
      &::_crypto_rsa_key_message_default_instance_);
}
inline ::crypto_rsa_key_message* crypto_key_message::release_rsakey() {
  // @@protoc_insertion_point(field_release:crypto_key_message.rsakey)
  _has_bits_[0] &= ~0x00000100u;
  ::crypto_rsa_key_message* temp = rsakey_;
  rsakey_ = nullptr;
  return temp;
}
inline ::crypto_rsa_key_message* crypto_key_message::mutable_rsakey() {
  _has_bits_[0] |= 0x00000100u;
  if (rsakey_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_rsa_key_message>(GetArenaNoVirtual());
    rsakey_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_key_message.rsakey)
  return rsakey_;
}
inline void crypto_key_message::set_allocated_rsakey(::crypto_rsa_key_message* rsakey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsakey_;
  }
  if (rsakey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsakey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsakey, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  rsakey_ = rsakey;
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.rsakey)
}

// optional .crypto_ecc_key_message ecckey = 9;
inline bool crypto_key_message::has_ecckey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void crypto_key_message::clear_ecckey() {
  if (ecckey_ != nullptr) ecckey_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::crypto_ecc_key_message& crypto_key_message::ecckey() const {
  const ::crypto_ecc_key_message* p = ecckey_;
  // @@protoc_insertion_point(field_get:crypto_key_message.ecckey)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_ecc_key_message*>(
      &::_crypto_ecc_key_message_default_instance_);
}
inline ::crypto_ecc_key_message* crypto_key_message::release_ecckey() {
  // @@protoc_insertion_point(field_release:crypto_key_message.ecckey)
  _has_bits_[0] &= ~0x00000200u;
  ::crypto_ecc_key_message* temp = ecckey_;
  ecckey_ = nullptr;
  return temp;
}
inline ::crypto_ecc_key_message* crypto_key_message::mutable_ecckey() {
  _has_bits_[0] |= 0x00000200u;
  if (ecckey_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_ecc_key_message>(GetArenaNoVirtual());
    ecckey_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_key_message.ecckey)
  return ecckey_;
}
inline void crypto_key_message::set_allocated_ecckey(::crypto_ecc_key_message* ecckey) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ecckey_;
  }
  if (ecckey) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ecckey = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecckey, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  ecckey_ = ecckey;
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.ecckey)
}

// optional string crypto_context = 10;
inline bool crypto_key_message::has_crypto_context() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void crypto_key_message::clear_crypto_context() {
  crypto_context_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& crypto_key_message::crypto_context() const {
  // @@protoc_insertion_point(field_get:crypto_key_message.crypto_context)
  return crypto_context_.GetNoArena();
}
inline void crypto_key_message::set_crypto_context(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  crypto_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_key_message.crypto_context)
}
inline void crypto_key_message::set_crypto_context(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  crypto_context_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_key_message.crypto_context)
}
inline void crypto_key_message::set_crypto_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  crypto_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_key_message.crypto_context)
}
inline void crypto_key_message::set_crypto_context(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  crypto_context_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_key_message.crypto_context)
}
inline std::string* crypto_key_message::mutable_crypto_context() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:crypto_key_message.crypto_context)
  return crypto_context_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_key_message::release_crypto_context() {
  // @@protoc_insertion_point(field_release:crypto_key_message.crypto_context)
  if (!has_crypto_context()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return crypto_context_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_key_message::set_allocated_crypto_context(std::string* crypto_context) {
  if (crypto_context != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  crypto_context_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), crypto_context);
  // @@protoc_insertion_point(field_set_allocated:crypto_key_message.crypto_context)
}

// -------------------------------------------------------------------

// crypto_encryption_algorithm_message

// required string encryption_algorithm_name = 1;
inline bool crypto_encryption_algorithm_message::has_encryption_algorithm_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_encryption_algorithm_name() {
  encryption_algorithm_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_encryption_algorithm_message::encryption_algorithm_name() const {
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.encryption_algorithm_name)
  return encryption_algorithm_name_.GetNoArena();
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_encryption_algorithm_message.encryption_algorithm_name)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_encryption_algorithm_message.encryption_algorithm_name)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_encryption_algorithm_message.encryption_algorithm_name)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_encryption_algorithm_message.encryption_algorithm_name)
}
inline std::string* crypto_encryption_algorithm_message::mutable_encryption_algorithm_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.encryption_algorithm_name)
  return encryption_algorithm_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_encryption_algorithm_message::release_encryption_algorithm_name() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.encryption_algorithm_name)
  if (!has_encryption_algorithm_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encryption_algorithm_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_encryption_algorithm_message::set_allocated_encryption_algorithm_name(std::string* encryption_algorithm_name) {
  if (encryption_algorithm_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encryption_algorithm_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algorithm_name);
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.encryption_algorithm_name)
}

// optional string message_id = 2;
inline bool crypto_encryption_algorithm_message::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_encryption_algorithm_message::message_id() const {
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.message_id)
  return message_id_.GetNoArena();
}
inline void crypto_encryption_algorithm_message::set_message_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_encryption_algorithm_message.message_id)
}
inline void crypto_encryption_algorithm_message::set_message_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_encryption_algorithm_message.message_id)
}
inline void crypto_encryption_algorithm_message::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_encryption_algorithm_message.message_id)
}
inline void crypto_encryption_algorithm_message::set_message_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_encryption_algorithm_message.message_id)
}
inline std::string* crypto_encryption_algorithm_message::mutable_message_id() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.message_id)
  return message_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_encryption_algorithm_message::release_message_id() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.message_id)
  if (!has_message_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_encryption_algorithm_message::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.message_id)
}

// optional .crypto_symmetric_key_message key_msg = 3;
inline bool crypto_encryption_algorithm_message::has_key_msg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_key_msg() {
  if (key_msg_ != nullptr) key_msg_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::crypto_symmetric_key_message& crypto_encryption_algorithm_message::key_msg() const {
  const ::crypto_symmetric_key_message* p = key_msg_;
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.key_msg)
  return p != nullptr ? *p : *reinterpret_cast<const ::crypto_symmetric_key_message*>(
      &::_crypto_symmetric_key_message_default_instance_);
}
inline ::crypto_symmetric_key_message* crypto_encryption_algorithm_message::release_key_msg() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.key_msg)
  _has_bits_[0] &= ~0x00000040u;
  ::crypto_symmetric_key_message* temp = key_msg_;
  key_msg_ = nullptr;
  return temp;
}
inline ::crypto_symmetric_key_message* crypto_encryption_algorithm_message::mutable_key_msg() {
  _has_bits_[0] |= 0x00000040u;
  if (key_msg_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto_symmetric_key_message>(GetArenaNoVirtual());
    key_msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.key_msg)
  return key_msg_;
}
inline void crypto_encryption_algorithm_message::set_allocated_key_msg(::crypto_symmetric_key_message* key_msg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete key_msg_;
  }
  if (key_msg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key_msg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_msg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  key_msg_ = key_msg;
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.key_msg)
}

// optional string encryption_algorithm_hmac_key = 4;
inline bool crypto_encryption_algorithm_message::has_encryption_algorithm_hmac_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_encryption_algorithm_hmac_key() {
  encryption_algorithm_hmac_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& crypto_encryption_algorithm_message::encryption_algorithm_hmac_key() const {
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
  return encryption_algorithm_hmac_key_.GetNoArena();
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_hmac_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  encryption_algorithm_hmac_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_hmac_key(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  encryption_algorithm_hmac_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_hmac_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  encryption_algorithm_hmac_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_hmac_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  encryption_algorithm_hmac_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
}
inline std::string* crypto_encryption_algorithm_message::mutable_encryption_algorithm_hmac_key() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
  return encryption_algorithm_hmac_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_encryption_algorithm_message::release_encryption_algorithm_hmac_key() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
  if (!has_encryption_algorithm_hmac_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return encryption_algorithm_hmac_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_encryption_algorithm_message::set_allocated_encryption_algorithm_hmac_key(std::string* encryption_algorithm_hmac_key) {
  if (encryption_algorithm_hmac_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encryption_algorithm_hmac_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algorithm_hmac_key);
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.encryption_algorithm_hmac_key)
}

// optional string encryption_algorithm_iv = 5;
inline bool crypto_encryption_algorithm_message::has_encryption_algorithm_iv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_encryption_algorithm_iv() {
  encryption_algorithm_iv_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& crypto_encryption_algorithm_message::encryption_algorithm_iv() const {
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.encryption_algorithm_iv)
  return encryption_algorithm_iv_.GetNoArena();
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_iv(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  encryption_algorithm_iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_encryption_algorithm_message.encryption_algorithm_iv)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_iv(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  encryption_algorithm_iv_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_encryption_algorithm_message.encryption_algorithm_iv)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_iv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  encryption_algorithm_iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_encryption_algorithm_message.encryption_algorithm_iv)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_iv(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  encryption_algorithm_iv_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_encryption_algorithm_message.encryption_algorithm_iv)
}
inline std::string* crypto_encryption_algorithm_message::mutable_encryption_algorithm_iv() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.encryption_algorithm_iv)
  return encryption_algorithm_iv_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_encryption_algorithm_message::release_encryption_algorithm_iv() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.encryption_algorithm_iv)
  if (!has_encryption_algorithm_iv()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return encryption_algorithm_iv_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_encryption_algorithm_message::set_allocated_encryption_algorithm_iv(std::string* encryption_algorithm_iv) {
  if (encryption_algorithm_iv != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  encryption_algorithm_iv_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algorithm_iv);
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.encryption_algorithm_iv)
}

// optional string encryption_algorithm_mode = 6;
inline bool crypto_encryption_algorithm_message::has_encryption_algorithm_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_encryption_algorithm_mode() {
  encryption_algorithm_mode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& crypto_encryption_algorithm_message::encryption_algorithm_mode() const {
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.encryption_algorithm_mode)
  return encryption_algorithm_mode_.GetNoArena();
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_mode(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  encryption_algorithm_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_encryption_algorithm_message.encryption_algorithm_mode)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_mode(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  encryption_algorithm_mode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_encryption_algorithm_message.encryption_algorithm_mode)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_mode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  encryption_algorithm_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_encryption_algorithm_message.encryption_algorithm_mode)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_mode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  encryption_algorithm_mode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_encryption_algorithm_message.encryption_algorithm_mode)
}
inline std::string* crypto_encryption_algorithm_message::mutable_encryption_algorithm_mode() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.encryption_algorithm_mode)
  return encryption_algorithm_mode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_encryption_algorithm_message::release_encryption_algorithm_mode() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.encryption_algorithm_mode)
  if (!has_encryption_algorithm_mode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return encryption_algorithm_mode_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_encryption_algorithm_message::set_allocated_encryption_algorithm_mode(std::string* encryption_algorithm_mode) {
  if (encryption_algorithm_mode != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  encryption_algorithm_mode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algorithm_mode);
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.encryption_algorithm_mode)
}

// optional string encryption_algorithm_pad = 7;
inline bool crypto_encryption_algorithm_message::has_encryption_algorithm_pad() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void crypto_encryption_algorithm_message::clear_encryption_algorithm_pad() {
  encryption_algorithm_pad_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& crypto_encryption_algorithm_message::encryption_algorithm_pad() const {
  // @@protoc_insertion_point(field_get:crypto_encryption_algorithm_message.encryption_algorithm_pad)
  return encryption_algorithm_pad_.GetNoArena();
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_pad(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  encryption_algorithm_pad_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_encryption_algorithm_message.encryption_algorithm_pad)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_pad(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  encryption_algorithm_pad_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_encryption_algorithm_message.encryption_algorithm_pad)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_pad(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  encryption_algorithm_pad_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_encryption_algorithm_message.encryption_algorithm_pad)
}
inline void crypto_encryption_algorithm_message::set_encryption_algorithm_pad(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  encryption_algorithm_pad_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_encryption_algorithm_message.encryption_algorithm_pad)
}
inline std::string* crypto_encryption_algorithm_message::mutable_encryption_algorithm_pad() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:crypto_encryption_algorithm_message.encryption_algorithm_pad)
  return encryption_algorithm_pad_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_encryption_algorithm_message::release_encryption_algorithm_pad() {
  // @@protoc_insertion_point(field_release:crypto_encryption_algorithm_message.encryption_algorithm_pad)
  if (!has_encryption_algorithm_pad()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return encryption_algorithm_pad_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_encryption_algorithm_message::set_allocated_encryption_algorithm_pad(std::string* encryption_algorithm_pad) {
  if (encryption_algorithm_pad != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  encryption_algorithm_pad_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algorithm_pad);
  // @@protoc_insertion_point(field_set_allocated:crypto_encryption_algorithm_message.encryption_algorithm_pad)
}

// -------------------------------------------------------------------

// crypto_key_store_message

// repeated .crypto_key_message key_entry = 1;
inline int crypto_key_store_message::key_entry_size() const {
  return key_entry_.size();
}
inline void crypto_key_store_message::clear_key_entry() {
  key_entry_.Clear();
}
inline ::crypto_key_message* crypto_key_store_message::mutable_key_entry(int index) {
  // @@protoc_insertion_point(field_mutable:crypto_key_store_message.key_entry)
  return key_entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto_key_message >*
crypto_key_store_message::mutable_key_entry() {
  // @@protoc_insertion_point(field_mutable_list:crypto_key_store_message.key_entry)
  return &key_entry_;
}
inline const ::crypto_key_message& crypto_key_store_message::key_entry(int index) const {
  // @@protoc_insertion_point(field_get:crypto_key_store_message.key_entry)
  return key_entry_.Get(index);
}
inline ::crypto_key_message* crypto_key_store_message::add_key_entry() {
  // @@protoc_insertion_point(field_add:crypto_key_store_message.key_entry)
  return key_entry_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto_key_message >&
crypto_key_store_message::key_entry() const {
  // @@protoc_insertion_point(field_list:crypto_key_store_message.key_entry)
  return key_entry_;
}

// -------------------------------------------------------------------

// crypto_signature

// required string encryption_algorithm_name = 1;
inline bool crypto_signature::has_encryption_algorithm_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void crypto_signature::clear_encryption_algorithm_name() {
  encryption_algorithm_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& crypto_signature::encryption_algorithm_name() const {
  // @@protoc_insertion_point(field_get:crypto_signature.encryption_algorithm_name)
  return encryption_algorithm_name_.GetNoArena();
}
inline void crypto_signature::set_encryption_algorithm_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_signature.encryption_algorithm_name)
}
inline void crypto_signature::set_encryption_algorithm_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_signature.encryption_algorithm_name)
}
inline void crypto_signature::set_encryption_algorithm_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_signature.encryption_algorithm_name)
}
inline void crypto_signature::set_encryption_algorithm_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encryption_algorithm_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_signature.encryption_algorithm_name)
}
inline std::string* crypto_signature::mutable_encryption_algorithm_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:crypto_signature.encryption_algorithm_name)
  return encryption_algorithm_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_signature::release_encryption_algorithm_name() {
  // @@protoc_insertion_point(field_release:crypto_signature.encryption_algorithm_name)
  if (!has_encryption_algorithm_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encryption_algorithm_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_signature::set_allocated_encryption_algorithm_name(std::string* encryption_algorithm_name) {
  if (encryption_algorithm_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encryption_algorithm_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_algorithm_name);
  // @@protoc_insertion_point(field_set_allocated:crypto_signature.encryption_algorithm_name)
}

// required string serialized_statement = 2;
inline bool crypto_signature::has_serialized_statement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void crypto_signature::clear_serialized_statement() {
  serialized_statement_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& crypto_signature::serialized_statement() const {
  // @@protoc_insertion_point(field_get:crypto_signature.serialized_statement)
  return serialized_statement_.GetNoArena();
}
inline void crypto_signature::set_serialized_statement(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_statement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_signature.serialized_statement)
}
inline void crypto_signature::set_serialized_statement(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_statement_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_signature.serialized_statement)
}
inline void crypto_signature::set_serialized_statement(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  serialized_statement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_signature.serialized_statement)
}
inline void crypto_signature::set_serialized_statement(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  serialized_statement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_signature.serialized_statement)
}
inline std::string* crypto_signature::mutable_serialized_statement() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:crypto_signature.serialized_statement)
  return serialized_statement_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_signature::release_serialized_statement() {
  // @@protoc_insertion_point(field_release:crypto_signature.serialized_statement)
  if (!has_serialized_statement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return serialized_statement_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_signature::set_allocated_serialized_statement(std::string* serialized_statement) {
  if (serialized_statement != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_statement_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_statement);
  // @@protoc_insertion_point(field_set_allocated:crypto_signature.serialized_statement)
}

// optional string signature = 3;
inline bool crypto_signature::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void crypto_signature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& crypto_signature::signature() const {
  // @@protoc_insertion_point(field_get:crypto_signature.signature)
  return signature_.GetNoArena();
}
inline void crypto_signature::set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_signature.signature)
}
inline void crypto_signature::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_signature.signature)
}
inline void crypto_signature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_signature.signature)
}
inline void crypto_signature::set_signature(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_signature.signature)
}
inline std::string* crypto_signature::mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:crypto_signature.signature)
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_signature::release_signature() {
  // @@protoc_insertion_point(field_release:crypto_signature.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_signature::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:crypto_signature.signature)
}

// optional string signer_name = 4;
inline bool crypto_signature::has_signer_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void crypto_signature::clear_signer_name() {
  signer_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& crypto_signature::signer_name() const {
  // @@protoc_insertion_point(field_get:crypto_signature.signer_name)
  return signer_name_.GetNoArena();
}
inline void crypto_signature::set_signer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  signer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto_signature.signer_name)
}
inline void crypto_signature::set_signer_name(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  signer_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:crypto_signature.signer_name)
}
inline void crypto_signature::set_signer_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  signer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto_signature.signer_name)
}
inline void crypto_signature::set_signer_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  signer_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto_signature.signer_name)
}
inline std::string* crypto_signature::mutable_signer_name() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:crypto_signature.signer_name)
  return signer_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* crypto_signature::release_signer_name() {
  // @@protoc_insertion_point(field_release:crypto_signature.signer_name)
  if (!has_signer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return signer_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void crypto_signature::set_allocated_signer_name(std::string* signer_name) {
  if (signer_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signer_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signer_name);
  // @@protoc_insertion_point(field_set_allocated:crypto_signature.signer_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_keys_2eproto
