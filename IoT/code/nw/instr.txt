SSL/TLS Client
From OpenSSLWiki

SSL/TLS Client is sample code for a basic web client that fetches a page. The code 
shown below omits error checking for brevity, but the sample available for download 
performs the error checking.  The code uses TLS (not SSL) and utilizes the Server 
Name Indication (SNI) extension from RFC 3546, Transport Layer Security (TLS) Extensions.

The code below does not perform hostname verification. OpenSSL prior to 1.1.0 
does not perform the check, and you must perform the check yourself. 
The OpenSSL Change Log for OpenSSL 1.1.0 states you can use -verify_name option, and 
apps.c offers -verify_hostname. But s_client does not respond to either switch, 
so its unclear how hostname checking will be implemented or invoked for a client.

Implementation
The code below demonstrates a basic client that uses BIOs and TLS to connect 
to www.random.org, and fetches 32 bytes of random data through an HTTP 
request. The sample code is available for download below.

#define HOST_NAME "www.random.org"
#define HOST_PORT "443"
#define HOST_RESOURCE "/cgi-bin/randbyte?nbytes=32&format=h"

long res = 1;

SSL_CTX* ctx = NULL;
BIO *web = NULL, *out = NULL;
SSL *ssl = NULL;

init_openssl_library();

const SSL_METHOD* method = SSLv23_method();
if(!(NULL != method)) handleFailure();
ctx = SSL_CTX_new(method);
if(!(ctx != NULL)) handleFailure();

SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, verify_callback);
SSL_CTX_set_verify_depth(ctx, 4);
const long flags = SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_COMPRESSION;
SSL_CTX_set_options(ctx, flags);

res = SSL_CTX_load_verify_locations(ctx, "random-org-chain.pem", NULL);
if(!(1 == res)) handleFailure();
web = BIO_new_ssl_connect(ctx);
if(!(web != NULL)) handleFailure();
res = BIO_set_conn_hostname(web, HOST_NAME ":" HOST_PORT);
if(!(1 == res)) handleFailure();
BIO_get_ssl(web, &ssl);
if(!(ssl != NULL)) handleFailure();
const char* const PREFERRED_CIPHERS = "HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4";
res = SSL_set_cipher_list(ssl, PREFERRED_CIPHERS);
if(!(1 == res)) handleFailure();
res = SSL_set_tlsext_host_name(ssl, HOST_NAME);
if(!(1 == res)) handleFailure();
out = BIO_new_fp(stdout, BIO_NOCLOSE);
if(!(NULL != out)) handleFailure();
res = BIO_do_connect(web);
if(!(1 == res)) handleFailure();
res = BIO_do_handshake(web);
if(!(1 == res)) handleFailure();

/* Step 1: verify a server certificate was presented during the negotiation */
X509* cert = SSL_get_peer_certificate(ssl);
if(cert) {
  X509_free(cert);
} /* Free immediately */
if(NULL == cert)
  handleFailure();

/* Step 2: verify the result of chain verification */
/* Verification performed according to RFC 4158    */
res = SSL_get_verify_result(ssl);
if(!(X509_V_OK == res))
  handleFailure();

/* Step 3: hostname verification */
BIO_puts(web, "GET " HOST_RESOURCE " HTTP/1.1\r\n"
              "Host: " HOST_NAME "\r\n"
              "Connection: close\r\n\r\n");
BIO_puts(out, "\n");

int len = 0;
do {
  char buff[1536] = {};
  len = BIO_read(web, buff, sizeof(buff));
            
  if(len > 0)
    BIO_write(out, buff, len);

} while (len > 0 || BIO_should_retry(web));

if(out)
  BIO_free(out);
if(web != NULL)
  BIO_free_all(web);
if(NULL != ctx)
  SSL_CTX_free(ctx);


Initialization
The sample program initializes the OpenSSL library with init_openssl_library. 
init_openssl_library calls three OpenSSL functions.

#if (SSLEAY_VERSION_NUMBER >= 0x0907000L)
# include <openssl/conf.h>
#endif
...

void init_openssl_library(void) {
  (void)SSL_library_init();

  SSL_load_error_strings();
  /* ERR_load_crypto_strings(); */
  OPENSSL_config(NULL);
    
  /* Include <openssl/opensslconf.h> to get this define */
#if defined (OPENSSL_THREADS)
  fprintf(stdout, "Warning: thread locking is not implemented\n");
#endif
}

SSL_library_init performs initialization of libcrypto and libssl, and 
loads required algorithms. The documents state SSL_library_init always 
returns 1, so its a useless return value.

OpenSSL_add_ssl_algorithms is a #define for SSL_library_init, so the call is omitted.

OPENSSL_config may (or may not) be needed. Internally, OPENSSL_config is 
called based on a configuration options via OPENSSL_LOAD_CONF. If you are 
dynamically loading an engine specified in openssl.cnf, then you might need 
it so you should call it. That is, don't depend upon the OpenSSL library 
to call it for you.

If you are building a multi-threaded client, you should set the locking 
callbacks. See threads(3) for details.


Context Setup
The sample program uses SSLv23_method to create a context. SSLv23_method specifies 
that version negotiation will be used. Do not be confused by the name 
(it does NOT mean that only SSLv2 or SSLv3 will be used). The name is like 
that for historical reasons, and the function has been renamed to TLS_method 
in the forthcoming OpenSSL version 1.1.0. Using this method will negotiate 
the highest protocol version supported by both the server and the client. 
SSL/TLS versions currently supported by OpenSSL 1.0.2 are SSLv2, SSLv3, TLS1.0, 
TLS1.1 and TLS1.2.

The actual SSL and TLS protocols are further tuned through options. By using 
SSLv23_method (and removing the unwanted protocol versions with SSL_OP_NO_SSLv2 
and SSL_OP_NO_SSLv3), then you will effectively use TLS v1.0 and above, 
including TLS v1.2. You can also use SSL_OP_NO_TLSv1 and SSL_OP_NO_TLSv1_1 if you 
want to use the TLS 1.2 protocol only.

SSL_CTX_new uses the SSLv23_method method to create a new SSL/TLS context object. 
If you use, for example TLSv1_method, then you will only use TLS v1.0, and if 
you use TLSv1_1_method then you will only use TLS v1.1. Typically you should 
always use SSLv23_method in preference to the version specific methods.

OpenSSL 1.1.0 improves protocol selection by providing SSL_CTX_set_max_proto_version() 
and SSL_CTX_set_min_proto_version(). You no longer need to subtract unwanted options 
with SSL_OP_NO_SSLv2 and SSL_OP_NO_SSLv3. Also see the SSL_CTX_set_max_proto_version() 
and SSL_CTX_set_min_proto_version() man pages.

Options (1)
After creating a context with SSLv23_method and SSL_CTX_new, the context object is 
tuned with the following functions:

SSL_CTX_set_verify
SSL_CTX_set_verify_depth
SSL_CTX_set_options
SSL_CTX_load_verify_locations
SSL_CTX_set_verify sets the SSL_VERIFY_PEER flag and the verify callback. 
This ensures the chain is verified according to RFC 4158 and Issuer and 
Subject information can be printed. If you don't want to perform custom 
processing (such as printing or checking), then don't set the callback. 
OpenSSL's default checking should be sufficient, so pass NULL to SSL_CTX_set_verify.

There is also a SSL_VERIFY_FAIL_IF_NO_PEER_CERT flag, but it is used for 
servers and has no effect on clients. If you accidentally use 
SSL_VERIFY_FAIL_IF_NO_PEER_CERT, then you chain will always verify when 
call SSL_get_verify_result because the flag is ignored for clients 
(essentially, 0 is passed for the flag which performs no verification).

SSL_CTX_set_verify_depth sets the chain depth to 4. Chain depth is fairly useless in practice.

SSL_CTX_set_options set the SSL_OP_ALL, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, 
SSL_OP_NO_COMPRESSION options. In essence, it takes all the bug fixes and 
work arounds for the various servers, removes the SSL protocols 
(leaving only TLS protocols), and removes compression. The remaining TLS 
protocols are TLS 1.0, TLS 1.1, and TLS 1.2.

SSL_CTX_load_verify_locations loads the certificate chain for the random.org site. 
The site's CA is Comodo, and the chain includes AddTrust External CA Root, 
COMODO Certification Authority, and COMODO Extended Validation Secure Server CA. 
Though the chain is provided, only the single trust anchor is needed for 
validation. The additional intermediate certs are provided to show how to 
concatenate and load them.

The PEM format means the file is a concatenation of Base64 encoded certificates 
with the -----BEGIN CERTIFICATE----- prologue (and associated epilogue). 
If the server sends all certificates required to verify the chain 
(which it should), then only the AddTrust External CA Root certificate is needed.

SSL BIO
The sample program uses BIOs for input and output. One BIO is used 
to connect to random.org, and a second BIO is used to print output to stdout.

BIO_new_ssl_connect creates a new BIO chain consisting of an SSL 
BIO (using ctx) followed by a connect BIO.

BIO_set_conn_hostname is used to set the hostname and port that 
will be used by the connection.

Options (2)
BIO_get_ssl is used to fetch the SSL connection object created by 
BIO_new_ssl_connect. The connection object inherits from the context 
object, and can override the settings on the context. The connection 
object is tuned with the following functions:

SSL_set_cipher_list
SSL_set_tlsext_host_name
SSL_set_cipher_list sets the cipher list. The list prefers elliptic curves, 
ephemeral [Diffie-Hellman], AES and SHA. It also removes NULL authentication 
methods and ciphers; and removes medium-security, low-security and 
export-grade security ciphers, such as 40-bit RC2. If desired, you 
could set the options on the context with SSL_CTX_set_cipher_list.

SSL_set_tlsext_host_name uses the TLS SNI extension to set the hostname. 
If you are connecting to a Server Name Indication-aware server 
(such as Apache with name-based virtual hosts or IIS 8.0), then 
you will receive the proper certificate during the handshake.

Cipher Suites

Wireshark and ClientHello
According to openssl ciphers ALL, there are just over 110 cipher suites 
available. Each cipher suite takes 2 bytes in the ClientHello, so advertising 
every cipher suite available at the client is going to cause a big 
ClientHello (or bigger then needed to get the job done). When using 
SSL_CTX_set_cipher_list or SSL_set_cipher_list with the string 
"HIGH:!aNULL:!kRSA:!PSK:!SRP:!MD5:!RC4", you'll cut the number of 
cipher suites down to about 45. If you know the server does not support 
DSA, then you can add "!DSS" and reduce the list further by about 7. 
And removing RSA key transport ("!kRSA") removes another 9 
more (this is a good practice because it uses ephemeral key exchanges 
which provide forward secrecy). Advertising 35 or so ciphers saves 
about 160 bytes in the ClientHello.

Better, pick 16 or 20 ciphers you want to support and advertise them. 
Order them so the GCM mode ciphers from TLS 1.2 are listed first, 
and the AES-SHA ciphers from TLS 1.0 are listed last. Though TLS 
1.0 should be avoided, its probably needed for interop because only 
about half the servers on the internet support TLS 1.2. If you control the 
server, then it should be offering TLS 1.2 and clients only need to 
advertise AEAD ciphers like AES/GCM or Camellia/GCM.


Connection

Wireshark and TLS versions
After setting the connection object options, the sample connects to the site and 
negotiates a secure channel.
BIO_do_connect
BIO_do_handshake
BIO_do_connect performs the name lookup for the host and standard TCP/IP three way handshake.

BIO_do_handshake performs the SSL/TLS handshake. If you set a callback with 
SSL_CTX_set_verify or SSL_set_verify, then you callback will be invoked for 
each certificate in the chain used during the execution of the protocol.

The Wireshark packet capture to the right shows the TLS handshake with the 
SNI extension encountered during the execution of BIO_do_handshake. 
OpenSSL 1.0.1e advertises TLSv1.2 as the highest protocol level in its ClientHello.

Callback
OpenSSL provides the ability for an application to interact with the chain 
validation by way of a callback. Normally, most application don't need to 
use it since the default OpenSSL behavior is usually adequate. In the callback, 
you can pass the preverify result back to the library (leaving library behavior 
unchanged), or you can modify the result to account for a specific issue that 
your software should address (override default behavior). If you don't need 
to interact with chain validation, then don't set the callback.

The example program returned the preverify result to the library and just 
printed information about the certificate in the chain. It did so by using 
SSL_CTX_set_verify with SSL_VERIFY_PEER and the verify_callback.

int verify_callback(int preverify, X509_STORE_CTX* x509_ctx) {
    int depth = X509_STORE_CTX_get_error_depth(x509_ctx);
    int err = X509_STORE_CTX_get_error(x509_ctx);
    
    X509* cert = X509_STORE_CTX_get_current_cert(x509_ctx);
    X509_NAME* iname = cert ? X509_get_issuer_name(cert) : NULL;
    X509_NAME* sname = cert ? X509_get_subject_name(cert) : NULL;
    
    print_cn_name("Issuer (cn)", iname);
    print_cn_name("Subject (cn)", sname);
    
    if(depth == 0) {
        /* If depth is 0, its the server's certificate. Print the SANs too */
        print_san_name("Subject (san)", cert);
    }

    return preverify;
}

The OpenSSL library will pass in the value of its preliminary checking of 
the certificate through preverify. If you always return 1 regardless of the 
value of preverify or the actual result of your processing, then 
SSL_get_verify_result will always return X509_V_OK. That's probably a 
bad idea for production software.

If you don't need to perform special processing on the chain, then you should 
forgo the verify_callback altogether by supplying NULL to SSL_CTX_set_verify:

SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, NULL);

Verification
You use one of two verification procedures, depending on the version of 
OpenSSL you are using. The change occurs at OpenSSL 1.1.0 because 1.1.0 
(and above) implements hostname verification that 1.0.2 (and below) 
lacked. Painting with a broad brush, minimal checking includes: (1) 
confirm the server has a certificate, (2) confirm the certificate chain 
verifies back to a trusted root, and (3) confirm the name of the host 
matches a hostname listed in the server's certificate.

OpenSSL 1.0.2
OpenSSL 1.0.2 and below requires at least three checks. These versions of 
OpenSSL do not perform hostname validation and the API user must perform it.

Server Certificate
You must confirm the server provided a certificate. This is because a server 
might be misconfigured, or the client and server used Anonymous Diffie-Hellman. 
You do so as follows:

X509* cert = SSL_get_peer_certificate(ssl);
if(cert) { X509_free(cert); }
if(NULL == cert) handleFailure();

If the server has a certificate, then SSL_get_peer_certificate will return 
a non-NULL value. You don't really need the certificate, so its free'd immediately.

Certificate Chain
You must confirm the server's certificate chains back to a trusted root, 
and all the certificates in the chain are valid. You do so as follows:

long res = SSL_get_verify_result(ssl);
if(!(X509_V_OK == res)) handleFailure();
SSL_get_verify_result returns the result of verifying the chain. See the 
earlier warning on doing the wrong thing in the verification callback.

Certificate Names
You must confirm a match between the hostname you contacted and the 
hostnames listed in the certificate. OpenSSL prior to 1.1.0 does 
not perform hostname verification, so you will have to perform 
the checking yourself. The sample code does not offer code at the 
moment, so you will need to borrow it or implement it.

If you want to borrow the code, take a look at libcurl and the verification
 procedure in source file ssluse.c. Another source is the C/C++ Secure 
Coding Guide and Section 10.8, Adding Hostname Checking to Certificate 
Verification. If you implement the code for checking, the sample code shows 
you how to extract the Common Name (CN) and Subject Alternate Names (SAN) 
from the certificate in print_cn_name and print_san_name.

Note: matching between the hostname (used in BIO_do_connect ) and names in 
the certificate (from SSL_get_peer_certificate) must also be validated. 
For example, a certificate cannot claim to be wildcarded for *.com, *.net, 
or other Top Level Domains (TLDs). In addition to the TLDs, you also have 
to country level or ccTLDs, so it can't match *.us, *.cn, *.fed.us, 
*.公司.cn or similar levels either. Mozilla maintains a list of ccTLDs 
that are off limits at the Public Suffix List, and there are currently 
6136 entries on the list.

Program Output
After all this musing, here's the lousy output you get when running the program:

Just do nothing.  Client sessions are not reused unless you explicitly
arrange for reuse of a session by calling SSL_set_session() before
SSL_connect().  If you're trying to avoid wasting memory on storing
client-side sessions that you'll never reuse then this may help:

   SSL_CTX_set_session_cache_mode(client_ctx, SSL_SESS_CACHE_OFF);

but note this is also the default state, so is also not needed unless
some other code has explicitly enabled client-side caching of sessions.

Only the server-side cache is enabled by default.
Session Tickets
Session tickets are specified in RFC 5077. You can disable session tickets with SSL_OP_NO_TICKET:

const long flags = SSL_OP_NO_SSLv3 | ... | SSL_OP_NO_TICKET;
SSL_CTX_set_options(ctx, flags);

Downloads
openssl-bio-fetch.tar.gz - The program and Makefile used for this wiki page.

#include <openssl/ssl.h>

 int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
 int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, unsigned char *d);
 int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_use_certificate(SSL *ssl, X509 *x);
 int SSL_use_certificate_ASN1(SSL *ssl, unsigned char *d, int len);
 int SSL_use_certificate_file(SSL *ssl, const char *file, int type);
 int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);
 int SSL_use_certificate_chain_file(SSL *ssl, const char *file);
 int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
 int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, unsigned char *d, long len);
 int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
 int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, unsigned char *d, long len);
 int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type);
 int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
 int SSL_use_PrivateKey_ASN1(int pk, SSL *ssl, unsigned char *d, long len);
 int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
 int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);
 int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, unsigned char *d, long len);
 int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);
 int SSL_CTX_check_private_key(const SSL_CTX *ctx);
 int SSL_check_private_key(const SSL *ssl);
 int SSL_CTX_use_cert_and_key(SSL_CTX *ctx, X509 *x, EVP_PKEY *pkey,
           STACK_OF(X509) *chain, int override);
 int SSL_use_cert_and_key(SSL *ssl, X509 *x, EVP_PKEY *pkey, 
           STACK_OF(X509) *chain, int override);
SSL_CTX_use_certificate() loads the certificate x into ctx, 
SSL_use_certificate() loads x into ssl. The rest of the certificates needed 
to form the complete certificate chain can be specified using the 
SSL_CTX_add_extra_chain_cert(3) function.
SSL_CTX_add_extra_chain_cert

SSL_CTX_add_extra_chain_cert, SSL_CTX_clear_extra_chain_certs - add or clear 
extra chain certificates

SYNOPSIS
 #include <openssl/ssl.h>

 long SSL_CTX_add_extra_chain_cert(SSL_CTX *ctx, X509 *x509);
 long SSL_CTX_clear_extra_chain_certs(SSL_CTX *ctx);

DESCRIPTION
SSL_CTX_add_extra_chain_cert() adds the certificate x509 to the extra chain 
certificates associated with ctx. Several certificates can be added one after another.

SSL_CTX_clear_extra_chain_certs() clears all extra chain certificates associated with ctx.

These functions are implemented as macros.

NOTES
When sending a certificate chain, extra chain certificates are sent in order 
following the end entity certificate.

If no chain is specified, the library will try to complete the chain from 
the available CA certificates in the trusted CA storage, see SSL_CTX_load_verify_locations(3).

The x509 certificate provided to SSL_CTX_add_extra_chain_cert() will be freed by 
the library when the SSL_CTX is destroyed. An application should not free the x509 object.

RESTRICTIONS
Only one set of extra chain certificates can be specified per SSL_CTX structure. 
Different chains for different certificates (for example if both RSA and DSA 
certificates are specified by the same server) or different SSL structures with 
the same parent SSL_CTX cannot be specified using this function. For 
more flexibility functions such as SSL_add1_chain_cert() should be used instead.

RETURN VALUES
SSL_CTX_add_extra_chain_cert() and SSL_CTX_clear_extra_chain_certs() return 1 
on success and 0 for failure. Check out the error stack to find out the reason 
for failure.

SEE ALSO
ssl(7), SSL_CTX_use_certificate(3), SSL_CTX_set_client_cert_cb(3), SSL_CTX_load_verify_locations(3) SSL_CTX_set0_chain(3) SSL_CTX_set1_chain(3) SSL_CTX_add0_chain_cert(3) SSL_CTX_add1_chain_cert(3) SSL_set0_chain(3) SSL_set1_chain(3) SSL_add0_chain_cert(3) SSL_add1_chain_cert(3) SSL_CTX_build_cert_chain(3) SSL_build_cert_chain(3)


certificate chain ends at root

SSL_CTX_use_PrivateKey() adds pkey as private key to ctx. 
SSL_CTX_use_RSAPrivateKey() adds the private key rsa of type RSA to ctx. 
SSL_use_PrivateKey() adds pkey as private key to ssl; 
SSL_use_RSAPrivateKey() adds rsa as private key of type RSA to ssl. 
If a certificate has already been set and the private does not belong 
to the certificate an error is returned. To change a certificate, 
private key pair the new certificate needs to be set with SSL_use_certificate() 
or SSL_CTX_use_certificate() before setting the private key 
with SSL_CTX_use_PrivateKey() or SSL_use_PrivateKey().

SSL_CTX_use_cert_and_key() and SSL_use_cert_and_key() assign the 
X.509 certificate x, private key key, and certificate chain onto the 
corresponding ssl or ctx. The pkey argument must be the private key 
of the X.509 certificate x. If the override argument is 0, 
then x, pkey and chain are set only if all were not previously set. 
If override is non-0, then the certificate, private key and 
chain certs are always set. If pkey is NULL, then the public key of 
x is used as the private key. This is intended to be used with hardware 
(via the ENGINE interface) that stores the private key securely, 
such that it cannot be accessed by OpenSSL. The reference count 
of the public key is incremented (twice if there is no private key); 
it is not copied nor duplicated. This allows all private key validations 
checks to succeed without an actual private key being assigned 
via SSL_CTX_use_PrivateKey(), etc.

X509_STORE_CTX_new

X509_STORE_CTX_new, X509_STORE_CTX_cleanup, X509_STORE_CTX_free, X509_STORE_CTX_init, X509_STORE_CTX_set0_trusted_stack, X509_STORE_CTX_set_cert, X509_STORE_CTX_set0_crls, X509_STORE_CTX_get0_chain, X509_STORE_CTX_set0_verified_chain, X509_STORE_CTX_get0_param, X509_STORE_CTX_set0_param, X509_STORE_CTX_get0_untrusted, X509_STORE_CTX_set0_untrusted, X509_STORE_CTX_get_num_untrusted, X509_STORE_CTX_set_default, X509_STORE_CTX_set_verify, X509_STORE_CTX_verify_fn - X509_STORE_CTX initialisation

SYNOPSIS
 #include <openssl/x509_vfy.h>

 X509_STORE_CTX *X509_STORE_CTX_new(void);
 void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);
 void X509_STORE_CTX_free(X509_STORE_CTX *ctx);
 int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,
                         X509 *x509, STACK_OF(X509) *chain);
 void X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);

 void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x);
 STACK_OF(X509) *X509_STORE_CTX_get0_chain(X609_STORE_CTX *ctx);
 void X509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *chain);
 void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk);
 X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx);
 void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);
 int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);
 STACK_OF(X509)* X509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx);
 void X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, STACK_OF(X509) *sk);
 int X509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx);
 typedef int (*X509_STORE_CTX_verify_fn)(X509_STORE_CTX *);
 void X509_STORE_CTX_set_verify(X509_STORE_CTX *ctx, X509_STORE_CTX_verify_fn verify);

DESCRIPTION
These functions initialise an X509_STORE_CTX structure for subsequent use by X509_verify_cert().
X509_STORE_CTX_new() returns a newly initialised X509_STORE_CTX structure.

X509_STORE_CTX_cleanup() internally cleans up an X509_STORE_CTX structure. 
The context can then be reused with an new call to X509_STORE_CTX_init().

X509_STORE_CTX_free() completely frees up ctx. After this call ctx is no 
longer valid. If ctx is NULL nothing is done.

X509_STORE_CTX_init() sets up ctx for a subsequent verification operation. 
It must be called before each call to X509_verify_cert(), i.e. a ctx is 
only good for one call to X509_verify_cert(); if you want to verify a 
second certificate with the same ctx then you must call X509_STORE_CTX_cleanup() 
and then X509_STORE_CTX_init() again before the second call to X509_verify_cert(). 
The trusted certificate store is set to store, the end entity certificate to 
be verified is set to x509 and a set of additional certificates (which 
will be untrusted but may be used to build the chain) in chain. Any or 
all of the store, x509 and chain parameters can be NULL.

X509_STORE_CTX_set0_trusted_stack() sets the set of trusted certificates of 
ctx to sk. This is an alternative way of specifying trusted certificates 
instead of using an X509_STORE.

X509_STORE_CTX_set_cert() sets the certificate to be verified in ctx to x.

X509_STORE_CTX_set0_verified_chain() sets the validated chain used by ctx 
to be chain. Ownership of the chain is transferred to ctx and should not 
be free'd by the caller. X509_STORE_CTX_get0_chain() returns a the internal 
pointer used by the ctx that contains the validated chain.

X509_STORE_CTX_set0_crls() sets a set of CRLs to use to aid certificate verification 
to sk. These CRLs will only be used if CRL verification is enabled in the 
associated X509_VERIFY_PARAM structure. This might be used where additional 
"useful" CRLs are supplied as part of a protocol, for example in a PKCS#7 structure.

X509_STORE_CTX_get0_param() retrieves an internal pointer to the verification 
parameters associated with ctx.

X509_STORE_CTX_get0_untrusted() retrieves an internal pointer to the stack of 
untrusted certificates associated with ctx.

X509_STORE_CTX_set0_untrusted() sets the internal point to the stack of untrusted 
certificates associated with ctx to sk.

X509_STORE_CTX_set0_param() sets the internal verification parameter pointer 
to param. After this call param should not be used.

X509_STORE_CTX_set_default() looks up and sets the default verification method 
to name. This uses the function X509_VERIFY_PARAM_lookup() to find an 
appropriate set of parameters from name.

X509_STORE_CTX_get_num_untrusted() returns the number of untrusted certificates 
that were used in building the chain following a call to X509_verify_cert().

X509_STORE_CTX_set_verify() provides the capability for overriding the default 
verify function. This function is responsible for verifying chain signatures 
and expiration times.

A verify function is defined as an X509_STORE_CTX_verify type which has 
the following signature:

 int (*verify)(X509_STORE_CTX *);
This function should receive the current X509_STORE_CTX as a parameter 
and return 1 on success or 0 on failure.

NOTES
The certificates and CRLs in a store are used internally and should not 
be freed up until after the associated X509_STORE_CTX is freed.

BUGS
The certificates and CRLs in a context are used internally and should 
not be freed up until after the associated X509_STORE_CTX is 
freed. Copies should be made or reference counts increased instead.

RETURN VALUES
X509_STORE_CTX_new() returns an newly allocates context or NULL is an error occurred.

X509_STORE_CTX_init() returns 1 for success or 0 if an error occurred.

X509_STORE_CTX_get0_param() returns a pointer to an X509_VERIFY_PARAM structure 
or NULL if an error occurred.

X509_STORE_CTX_cleanup(), X509_STORE_CTX_free(), X509_STORE_CTX_set0_trusted_stack(), 
X509_STORE_CTX_set_cert(), X509_STORE_CTX_set0_crls() and 
X509_STORE_CTX_set0_param() do not return values.
X509_STORE_CTX_set_default() returns 1 for success or 0 if an error occurred.
X509_STORE_CTX_get_num_untrusted() returns the number of untrusted certificates used.

SEE ALSO
X509_verify_cert(3) X509_VERIFY_PARAM_set_flags(3)

HISTORY
X509_STORE_CTX_set0_crls() was first added to OpenSSL 1.0.0 
X509_STORE_CTX_get_num_untrusted() was first added to OpenSSL 1.1.0


STACK_OF(X509) *chain = SSL_get_peer_cert_chain(ssl);
X509_STORE_CTX* newCert = X509_STORE_CTX_new();
if(newCert){
    X509_STORE_CTX_set_chain(newCert, chain);
    std::cout << X509_verify_cert(newCert) << std::endl;
}

int main(void) {
	STACK_OF(X509)	*stack;
	X509		*x;

	if ((stack = sk_X509_new_null()) == NULL)
		err(1, NULL);
	if ((x = X509_new()) == NULL)
		err(1, NULL);
	if (sk_X509_push(stack, x) == 0)
		err(1, NULL);
	if (X509_up_ref(x) == 0)
		errx(1, "X509_up_ref failed");
	if (sk_X509_push(stack, x) == 0)
		err(1, NULL);
	printf("%d pointers: %p, %p\n", sk_X509_num(stack),
	    sk_X509_value(stack, 0), sk_X509_value(stack, 1));
	sk_X509_pop_free(stack, X509_free);

	return 0;
}

bool RSASign( RSA* rsa, const unsigned char* Msg, size_t MsgLen,
              unsigned char** EncMsg, size_t* MsgLenEnc) {
  EVP_MD_CTX* m_RSASignCtx = EVP_MD_CTX_create();
  EVP_PKEY* priKey  = EVP_PKEY_new();
  EVP_PKEY_assign_RSA(priKey, rsa);
  if (EVP_DigestSignInit(m_RSASignCtx,NULL, EVP_sha256(), NULL,priKey)<=0) {
      return false;
  }
  if (EVP_DigestSignUpdate(m_RSASignCtx, Msg, MsgLen) <= 0) {
      return false;
  }
  if (EVP_DigestSignFinal(m_RSASignCtx, NULL, MsgLenEnc) <=0) {
      return false;
  }
  *EncMsg = (unsigned char*)malloc(*MsgLenEnc);
  if (EVP_DigestSignFinal(m_RSASignCtx, *EncMsg, MsgLenEnc) <= 0) {
      return false;
  }
  EVP_MD_CTX_cleanup(m_RSASignCtx);
  return true;
}

bool RSAVerifySignature( RSA* rsa, unsigned char* MsgHash, size_t MsgHashLen, 
                         const char* Msg, size_t MsgLen, bool* Authentic) {
  *Authentic = false;
  EVP_PKEY* pubKey  = EVP_PKEY_new();
  EVP_PKEY_assign_RSA(pubKey, rsa);
  EVP_MD_CTX* m_RSAVerifyCtx = EVP_MD_CTX_create();
  if (EVP_DigestVerifyInit(m_RSAVerifyCtx, NULL, EVP_sha256(), NULL, pubKey)<=0) {
    return false;
  }
  if (EVP_DigestVerifyUpdate(m_RSAVerifyCtx, Msg, MsgLen) <= 0) {
    return false;
  }
  int AuthStatus = EVP_DigestVerifyFinal(m_RSAVerifyCtx, MsgHash, MsgHashLen);
  if (AuthStatus==1) {
    *Authentic = true;
    EVP_MD_CTX_cleanup(m_RSAVerifyCtx);
    return true;
  } else if(AuthStatus==0){
    *Authentic = false;
    EVP_MD_CTX_cleanup(m_RSAVerifyCtx);
    return true;
  } else{
    *Authentic = false;
    EVP_MD_CTX_cleanup(m_RSAVerifyCtx);
    return false;
  }
}

bool verifySignature(std::string publicKey, std::string plainText, char* signatureBase64) {
  RSA* publicRSA = createPublicRSA(publicKey);
  unsigned char* encMessage;
  size_t encMessageLength;
  bool authentic;
  Base64Decode(signatureBase64, &encMessage, &encMessageLength);
  bool result = RSAVerifySignature(publicRSA, encMessage, encMessageLength, 
                  plainText.c_str(), plainText.length(), &authentic);
  return result & authentic;
}


#include <openssl/crypto.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

#define CHK_NULL(x) if((x) == NULL) exit(1);
#define CHK_ERR(err, s) if((err) == -1) { perror(s); exit(1); }
#define CHK_SSL(err) if((err) == -1) { ERR_print_errors_fp(stderr); exit(2); }

int main(void) {
    int err;
    int sd;
    struct sockaddr_in sa;

    SSL_CTX   *ctx;
    SSL     *ssl;
    X509                    *server_cert;
    char                    *str;
    char                    buf[4096];
    SSL_METHOD    *meth;

    SSL_load_error_strings();
    SSLeay_add_ssl_algorithms();
    meth = TLSv1_2_client_method();
    ctx = SSL_CTX_new(meth);
    CHK_NULL(ctx);

    if(SSL_CTX_use_certificate_file(ctx, "./client.crt", SSL_FILETYPE_PEM) <= 0) {
        ERR_print_errors_fp(stderr);
        exit(3);
    }

    if(SSL_CTX_use_PrivateKey_file(ctx, "./client.key", SSL_FILETYPE_PEM) <= 0) {
    ERR_print_errors_fp(stderr);
    exit(4);
    }

    if(!SSL_CTX_check_private_key(ctx)) {
        fprintf(stderr, "Private key does not match the certificate public keyn");
        exit(5);
    }

    CHK_SSL(err);

    sd = socket(AF_INET, SOCK_STREAM, 0);
    CHK_ERR(sd, "socket");

    memset(&sa, 0x00, sizeof(sa));
    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = inet_addr("127.0.0.1");
    sa.sin_port = htons(1111);

    err = connect(sd, (struct sockaddr*)&sa, sizeof(sa));
    CHK_ERR(err, "connect");

    ssl = SSL_new(ctx);
    CHK_NULL(ssl);

    SSL_set_fd(ssl, sd);
    err = SSL_connect(ssl);
    CHK_NULL(err);

    printf("SSL connection using %s \n", SSL_get_cipher(ssl));

    server_cert = SSL_get_peer_certificate(ssl);
    CHK_NULL(server_cert);
    printf("Server certificate: \n");

    str = X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);
    CHK_NULL(str);
    printf("\t subject: %s \n", str);
    OPENSSL_free(str);

    str = X509_NAME_oneline(X509_get_issuer_name(server_cert), 0, 0);
    CHK_NULL(str);
    printf("\t issuer: %s \n", str);
    OPENSSL_free(str);

    X509_free(server_cert);

    err = SSL_write(ssl, "Hello World!", strlen("Hello World!"));
    CHK_SSL(err);

    err = SSL_read(ssl, buf, sizeof(buf)-1);
    CHK_SSL(err);
    buf[err] = 0x0;
    printf("Got %d chars: %s \n", err, buf);
    SSL_shutdown(ssl);

    close(sd);
    SSL_free(ssl);
    SSL_CTX_free(ctx);

    return 0;
}


Server
  SSL_load_error strings
  socket(AF_INET, addr, 0)
  bind
  listen
  get_certificate_store(ctx)
  sk_509_stack_null
  sk_509_push(root)
  sk_509_push(server_cert)
  SSL_CTX_use_cert_and_key
  SSL_CTX_set_certify(SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE)
  loop
    a = accept()
    ctx= ssl_new
    ssl_set_verify
    ssl_set_fd(ssl, a)

server-thread
  sd= SSL_get_fd
  SSL_accept
  SSL_read
  SSL_write
  close(sd)
  SSL_free


Client
  socket
  gethostaddress
  connect
  ctx= SSL_new
  SSL_set_cipher_list
  SSL_set_verify(SSL_VERIFY_PEER)
  SSL_set_fd(sd)
  SSL_CTX_set_options
  SSL_set_cipher_list
  load certs as above
  ssl_set_verify
  SSL_connect
  SSL_get_peer_certificate
  SSL_get_cipher
  SSL_read
  SSL_write
    close(sd)
  SSL_free
  

 
Any TLS communication starts with a TLS handshake, which establishes what protocol will be used. We will focus on this page about what happens when the TLS_DHE_RSA_WITH_AES_128_CBC_SHA cipher suite is used (see SSL/TLS for more information about what this means)

Contents [hide] 
1 Handshake Overview
2 Client Hello Message
3 Server Hello Message
4 Certificate Message
5 Key Exchange
6 Server Key Exchange Message
7 Server Hello Done Message
8 Client Key Exchange Message
9 Change Cipher Spec Message
10 Another Key Exchange: Elliptical Curve Diffie Hellman Ephemeral
11 Another Key Exchange: RSA
12 SSL Certificate (optional)
13 Encrypted Handshake Message
Handshake Overview
Most packets during the communication are of type Handshake (0x16) and are followed by a Handshake packet header:

typedef struct __attribute__((packed)) {
	uint8_t content_type;  // 0x16
	uint16_t version;
	uint16_t length;
} TLSRecord;
This header may be followed by another TLS header, such as a TLS Handshake header. Like for a TCP connection, a TLS connection starts with a handshake between the client and the server:

The client sends a Client Hello message, including a list of 32-byte list of random data and the list of its supported cipher suites. In our example we only send one supported cipher suite (code 0x0033)
The server responds with a Server Hello message, telling the client what cipher suite is going to be used as well as its own 32-byte list of random data
The server sends its certificates. These are used by the client to verify that it is actually talking to the site it thinks it is talking to, as opposed to a malicious site
The server sends a Server Key Exchange message, initiating the key exchange and signing it with its public key
The server sends a Server Hello Done message, indicating it is waiting for the client
The client sends a Client Key Exchange message, containing its part of the key exchange transaction
The client sends a Change Cipher Spec message
The client sends a Encrypted Handshake Message
The server sends a Change Cipher Spec
The server sends a Encrypted Handshake Message
The client and the server can communicate by exchanging encrypted Application Data messages
The Change Cipher Spec message tells the other party its is OK with the terms of the handshake.

The Encrypted Handshake messages are the first ones to be sent encrypted. They contain a hash of the initial handshake messages and are here to ensure these were not tampered with.

Any subsequent communication is of type Application Data and encrypted.

Client Hello Message
The Client Hello message initiates the TLS handshake. It is composed of a specific header, followed by some (optional) extensions, followed by some optional padding. If some servers such as wikipedia.org are quite forgiving in the types of Client Hello messages they accept, others such as Google require the Client Hello message to be exactly 512 bytes (excluding the TLS Record header) and declare a server_name extension

Here is an example of a Client Hello message:

0000   01 00 01 fc 03 03 57 16 ea ce ec 93 89 5c 4a 18
0010   d3 1c 5f 37 9b b3 05 b4 32 08 29 39 b8 3e e0 9f
0020   9a 96 ba be 0a 40 00 00 02 00 33 01 00 01 d1 ff
0030   01 00 01 00 00 00 00 16 00 14 00 00 11 77 77 77
0040   2e 77 69 6b 69 70 65 64 69 61 2e 6f 72 67 00 0d
0050   00 12 00 10 06 01 06 03 05 01 05 03 04 01 04 03
0060   02 01 02 03 00 0b 00 02 01 00 00 0a 00 06 00 04
0070   00 17 00 18 00 15 01 88 00 00 00 00 00 00 00 00
0080   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
...
01e0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
01f0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x01: Client Hello handshake type
0x0001FC: size=508 (512-4)
0x0303: TLS 1.2
0x5716...0A40: 32-bytes random client data
0x00: session ID length=0 (if it was not null, it would be followed by the session ID)
0x0002: Cipher Suites Length=2 (1 cipher suite supported)
0x0033: TLS_DHE_RSA_WITH_AES_128_CBC_SHA cipher suite code
0x01: number of compression methods=1
0x00: compression method=null
0x01D1: extensions length=465
0xFF01: extension type=renegotiation_info
0x0001: length=1
0x00: renegotiation info extension length=0
0x0000: extension type=server_name (the domain name we are trying to contact)
0x0016: length=22
0x0014: server name list length=20
0x00: server name type=host_name
0x0011: server name length=17
0x7777772E...7267: "www.wikipedia.org"
0x000D: extension type=signature_algorithms (the signature algorithms supported)
0x0012: length=18
0x0010: signature hash algorithms length=16
0x0601: SHA512 + RSA
0x0603: SHA512 + ECDSA
0x0501: SHA384 + RSA
0x0503: SHA384 + ECDSA
0x0401: SHA256 + RSA
0x0403: SHA256 + ECDSA
0x0201: SHA1 + RSA
0x0203: SHA1 + ECDSA
0x000B: extension type=ec_point_formats (only used if you use elliptic curve cryptography)
0x0002: length=2
0x02: EC point formats length=1
0x00: EC point format=uncompressed
0x000A: extension type=elliptic_curves (Elliptic Curve types supported - only used if you use elliptic curve cryptography)
0x0006: length=6
0x0004: elliptic curve length=4 (2 curves)
0x0017: secp256r1 elliptic curve
0x0018: secp384r1 elliptic curve
0x0015: extension type=padding (we fill the rest of the 512 bytes with zeros)
0x0188: length=392
0x0000...0000: 392 bytes of padding data
Server Hello Message
The Server Hello message indicates which cipher suite is going to be used and provides some server random data that will be used later on.

Here is a sample Server Hello message:

0000   02 00 00 4d 03 03 c8 ca 5c 5f 83 79 eb 8f 8a 16
0010   86 c2 07 d7 42 c7 ee b9 dc 71 b7 f1 71 9f eb 51
0020   66 24 b4 1e 4f 6c 20 e4 02 80 10 1d ea 7f aa ee
0030   5d 4f ac 53 49 29 25 ec 29 a8 b7 23 fa ef 24 d4
0040   47 2e 90 7b 99 36 2b 00 33 00 00 05 ff 01 00 01
0050   00
0x02: Handshake type=Server Hello
0x00004D: length=77
0x0303: TLS version 1.2
0xC8CA...4F6C: 32-bytes server random data
0x20: session ID length=32
0xE402...362B: session ID (can be used in a future TLS connection to avoid going through the handshake again)
0x0033: cipher suite used=TLS_DHE_RSA_WITH_AES_128_CBC_SHA
0x00: compression method used=null
0x0005: extensions length=5
0xFF01: extension type=renegotiation_info
0x0001: length=1
0x00: renegotiation info extension length=0
Certificate Message
The server then sends a Certificate message containing its SSL Certificate chain. The first certificate is the server's SSL certificate. The next certificate is the certificate from a Certificate Authority (CA) which signed the first certificate. The next certificate signs the previous certificate, and so on. The last certificate in the chain should belong to a root CA and is self-signed (each TLS client should have a list of all the root CAs)

Here is how the Certificate Message is encoded:

0x0B: handshake type=Certificate
0x000C58: length=3160
0x000C55: certificates length=3157
0x0007E2: certificate #1 Length=2018
0x3082...C0F3: first certificate (ASN.1 encoded)
0x00046D: certificate #2 length=1133
0x3080...4998: second certificate (ASN.1 encoded)
Key Exchange
TLS encryption is performed using symmetric encryption. The client and server thus need to agree on a secret key. This is done in the key exchange protocol.

In our example, TLS is using the DHE/RSA algorithms: the Diffie-Hellman Ephemeral protocol is used to come up with the secret key, and the server is using the RSA protocol to sign the numbers it sends to the client (the signature is linked to its SSL certificate) to ensure that a third party cannot inject a malicious number. The upside of DHE is that it is using a temporary key that will be discarded afterwards. Key exchange protocols such as DH or RSA are using numbers from the SSL certificate. As a result, a leak of the server's private key (for example through Heartbleed) means that a previously recorded SSL/TLS encryption can be decrypted. Ephemeral key exchange protocols such as DHE or ECDHE offer so-called forward secrecy and are safe even if the server's private key is later compromised.

Diffie-Hellman Ephemeral works as follows:

The server comes up with a secret number y, with a number g and a modulo p (p typically being a 1024 bit integer) and sends (p, g, pubKey=gy mod p) to the client in its "Server Key Exchange" message. It also sends a signature of the Diffie-Hellman parameters (see SSL Certificate section)
The client comes up with a secret number x and sends pubKey=gx mod p to the server in its "Client Key Exchange" message
The client and server derive a common key premaster_secret = (gx)y mod p = (gy)x mod p = gxy mod p. If p is large enough, it is extremely hard for anyone knowing only gx and gy (which were transmitted in clear) to find that key.
Because computing gxy mod p using 1024-bytes integers can be tedious in most programming languages, if security is not a concern, one way to avoid this is to use x=1. This way, premaster_secret is just gy mod p, a value directly sent by the server. The security in such a case is of course compromised.

premaster_key is however only a first step. Both client and server uses the PRF function to come up with a 48-byte master secret. The PRF function is used once again to generate a 104-bytes series of data which will represent all the secret keys used in the conversation (the length may differ depending on the cipher suite used):

# g_y, g and p are provided in the Server Key Exchange message
# The client determines x
premaster_secret = pow(g_y, x, p)
 
# client_random and sever_random are the 32-bytes random data from the Client Hello and Server Hello messages
master_secret = PRF(premaster_secret, "master secret", client_random + server_random, 48)
keys = PRF(master_secret, "key expansion", server_random + client_random, 104)
 
# The MAC keys are 20 bytes because we are using HMAC+SHA1
client_write_MAC_key = keys[0:20]
server_write_MAC_key = keys[20:40]
# The client and server keys are 16 bytes because we are using AES 128-bit aka a 128 bit = 16 bytes key
client_write_key = keys[40:56]
server_write_key = keys[56:72]
# The IVs are always 16 bytes because AES encrypts blocks of 16 bytes
client_write_IV = keys[72:88]
server_write_IV = keys[88:104]
Note how different secret keys are used for the client and for the server, as well as for encryption and to compute the MAC.

Server Key Exchange Message
The server then sends its part of the key exchange. In the following case it will send the Diffie-Hellman parameters p, g and pubKey=gy

0x0C: handshake type=server key exchange
0x00030B: length=779
0x0100: p length=256
..... : 256-bytes p (1024-bit integer)
0x0001: g length=1
0x02: g = 2
0x0100: pubKey length
... : 256-bytes pubKey
0x0601: signature hash algorithm used to sign the Diffie-Hellman parameters=SHA512+RSA
0x0100: signature length=256
... : 256-bytes signature
Server Hello Done Message
This message indicates that the server is done and is awaiting for client input.

typedef struct __attribute__((packed)) {
	uint8_t handshake_type;  // 0x0E
	uint8_t length[3];  // 0x000000
} TLSServerHelloDone;
Client Key Exchange Message
The client then sends its key exchange parameters: pubKey=gx

0x10: handshake type=client key exchange
0x000102: length=258
0x0100: pubKey length=256
...: 256-bytes pubKey
Change Cipher Spec Message
The client sends the Change Cipher Spec message to indicate it has completed its part of the handshake. The next message the server will expect is the Encrypted Handshake Message.

The whole message (including the TLS Record header) is 6 bytes long:

typedef struct __attribute__((packed)) {
	uint8_t content_type;  // 0x14
        uint16_t version; // 0x0303 for TLS 1.2
	uint8_t length;  // 0x01
        uint8_t content;  // 0x01
} TLSChangeCipherSpec;
Another Key Exchange: Elliptical Curve Diffie Hellman Ephemeral
If Diffie-Hellman is a very powerful algorithm, it requires very large numbers to be considered secure (1024-bit at minimum). A variant is Elliptical Curve Diffie-Hellman, which is much harder to break even with 256-bit numbers. Numerous TLS cipher suites now rely on the ECDHE_RSA key exchange instead of DHE_RSA, like in the TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA cipher suite.

Elliptic Curve Diffie-Hellman works as follows: consider a point G = (x, y) on a curve y2 = x3 + a.x + b mod p. Both parties come up with secret numbers secret1 and secret2, and will send each other G.secret1 and G.secret2 (G.secret1 means multiplying the point G to secret1 using Elliptic Curve point multiplication). The shared secret key is G.secret1.secret2.

TLS can use the ECDHE key exchange to come up with an ephemeral shared secret key the following way:

The server indicates in the Server Key Exchange message what type of curve is going to be used (secp256r1 is a very common one). This tells what parameters a, b, p and G to use (see [1] to see the domain parameters for each curve)
The server comes up with a random 256-bit number (or whatever the curve says) server_secret and sends pubKey = G*server_secret in the Server Key Exchange message. pubKey is sent as a 65-bytes block composed of the concatenation 0x04 | Gx | Gy (both numbers being 32-bytes long)
The client comes up with a random 256-bit number client_secret and sends pubKey = G*client_secret in the Client Key Exchange message. pubKey is sent in the same format as the server's
Both parties will derive premaster_secret by computing server_pubKey * client_secret = client_pubKey * server_secret = G * client_secret * server_secret. The x coordinate of this result is the premaster_secret
Once premaster_secret is determined, the rest of the computation works the same regardless of the key exchange protocol used
Regarding how to compute elliptic curve point multiplication, Wikipedia offers more details. Note that, because we are only dealing with integers, you should use modular multiplicative inverse instead of divisions.

If you want to test Elliptic Curves in Python, TinyEC is a very useful package (along with the source code in pure Python):

import tinyec.ec as ec
import tinyec.registry as reg
 
# Get the domain parameters for the named curve specified in the Server Key Exchange message
curve = reg.get_curve("secp256r1")
 
# Comes up with a random 256-bit (32 bytes) client_secret
# curve.g is a point on the elliptic curve, defined by the domain parameters
# We multiply it with client_secret to obtain the public key
client_pubKey = curve.g * client_secret
# Retrieved from the Server Key Exchange message
server_pubKey = ...
 
premaster_secret = (server_pubKey * client_secret).x
Another Key Exchange: RSA
The RSA key exchange is by today's standard an old key exchange protocol and does not provide forward secrecy. It is however simpler to implement than ECDHE and still supported by multiple sites (for example, Google supports the RSA key exchange but not the simple Diffie-Hellman key exchange).

With the RSA key exchange, the server does not send any "Server Key Exchange" message. Instead, the client decides the premaster_secret, which is a 48-bytes string composed of a two-bytes TLS version (0x0303 for TLS 1.2) followed by 46 random bytes. It then encrypts that premaster_secret using the PKCS #1 protocol (aka RSA encryption version 1.5) as well as the key from the Web site's certificate as the public key. Because the public key is always the same, a leak of the Web site's private key would allow to decrypt previously recorded TLS conversations. This is why the RSA key exchange protocol offers no forward secrecy.

import os
from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
 
# Come up with a random premaster_secret
# It is recommended to use a random generator from a crypto library if possible
premaster_secret = '\x03\x03' + os.urandom(46)
 
# Retrieve the pubKey from the first certificate. This pubKey value (65-bytes for a 1024-bit public key) is stored in the ASN.1 format
key = RSA.importKey(pubKey)
 
# Encrypt the premaster_secret
cipher = PKCS1_v1_5.new(key)
encrypted_premaster_secret = cipher.encrypt(premaster_secret)
Without the Crypto.Cipher.PKCS1_v1_5 package:

import os
 
# Come up with a random premaster_secret
premaster_secret = '\x03\x03' + os.urandom(46)
 
# Retrieve the pubKey from the first certificate (parse_ASN1 is a fictional function)
RSA_n, RSA_e = parse_ASN1(pubKey)
 
# Encrypt the premaster_secret
premaster_secret = '\x00\x02' + '\x42' * (256 - 3 - len(premaster_secret)) + '\x00' + premaster_secret
encrypted_premaster_secret = pow(to_int(premaster_secret), RSA_e, RSA_n)
SSL Certificate (optional)
In order to prevent a Man-In-The-Middle attack (MITM), the server will sign the Diffie-Hellman parameters it sent to the client. Because the client may have never contacted the server before (and thus cannot securely obtain its public key), the client and server rely on a trusted third party known as a Certificate Authority (CA).

In order to verify the signature using the RSA algorithm, the client need to do the following:

Retrieve the Certificate message sent by the server, which contains one or more certificates (look at a such a packet in Wireshark)
Verify that the first certificate's RDN sequence (signedCertificate / subject:rdnSequence / rdnSequence) contains the Web site the client is trying to contact
Get the RSA e and n values from the first certificate's public key (signedCertificate / subjectPublicKeyInfo / subjectPublicKey). Those parameters are encoded using the ASN.1 format (as a verification, e is very often 65537, or 0x10001)
Compute the hash of the whole DH parameters (as sent by the server) preceded with the client and server random data. The certificate indicates what type of hash to use (signedCertificate / subjectPublicKeyInfo / algorithm):
Compute signaturee mod n, convert it to a string and take the last 20 bytes (or more, depending on the hash function being used)
Both computations should be the same
Because this certificate is probably generated by an intermediate CA, the client needs to verify that certificate
Compute the hash of the whole signedCertificate section and repeat the operation using the next certificate
Follow the certificate chain up to the end. The last certificate should belong to a root CA (any TLS implementation should contain a list of the root CAs and their public key) and is self-signed
Encrypted Handshake Message
The TLS handshake is concluded with the two parties sending a hash of the complete handshake exchange, in order to ensure that a middleman did not try to conduct a downgrade attack.

If your TLS client technically does not have to verify the Encrypted Handshake Message sent by the server, it needs to send a valid Encrypted Handshake Message of its own, otherwise the server will abort the TLS session.

Here is what the client needs to do to create :

Compute a SHA256 hash of a concatenation of all the handshake communications (or SHA384 if the PRF is based on SHA384). This means the Client Hello, Server Hello, Certificate, Server Key Exchange, Server Hello Done and Client Key Exchange messages. Note that you should concatenate only the handshake part of each TLS message (i.e. strip the first 5 bytes belonging to the TLS Record header)
Compute PRF(master_secret, "client finished", hash, 12) which will generate a 12-bytes hash
Append the following header which indicates the hash is 12 bytes: 0x14 0x00 0x00 0x0C
Encrypt the 0x14 0x00 0x00 0x0C | [12-bytes hash] (see the Encrypting / Decrypting data section). This will generate a 64-bytes ciphertext using AES-CBC and 40 bytes with AES-GCM
Send this ciphertext wrapped in a TLS Record
The server will use a similar algorithm, with two notable differences:

It needs to compute a hash of the same handshake communications as the client as well as the decrypted "Encrypted Handshake Message" message sent by the client (i.e. the 16-bytes hash starting with 0x1400000C)
It will call PRF(master_secret, "server finished", hash, 12)
